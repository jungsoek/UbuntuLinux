# 리눅스 소개와 전망

**이번 장에서 다룰 내용**

* 리눅스는 왜 배워야 할까?
* 리눅스의 전망
* 임베디드 리눅스 개발 단체
* 임베디드 리눅스 개발자는 무엇을 알아야 할까?

2000년대 초반까지만 해도 리눅스는 교육용 혹은 서버에서만 사용하던 운영체제였다. 하지만 2020년을 맞이하는 현재, 리눅스는 광범위하게 사용되고 있으며, 그 저변은 계속 확대되고 있다.

## 리눅스 커널은 왜 배워야 할까?

리눅스 세미나에서 다음과 같은 질문을 종종 받곤 한다.

*리눅스를 배워야 하는 이유가 무엇인가요?*

이 질문은 특히 리눅스를 처음 접하는 분들이 많이 던지는 질문이었다. 이런 질문을 받고는 리눅스를 과연 왜 배워야 할까, 곰곰히 생각해봤다. 여러 생각 끝에 다음과 같은 결론을 내리게 됐다.

*소프트웨어 개발을 하려고 한다면 리눅스를 반드시 알아야 한다.*

그래서 이번 절에서는 먼저 리눅스를 왜 배워야 하는지 설명한다.

### 리눅스는 왜 배워야 할까?

최근 IT 직무 기술로 리눅스가 채택되어 IT 아카데미에서 '리눅스'를 교육 과정으로 운영하는 곳이 많다. 대학교 학부 과정에서도 리눅스 시스템 프로그래밍을 배울 수 있다. 또한 대학원 프로젝트 과제도 리눅스 환경에서 수행되는 경우가 많다. 이처럼 리눅스는 정규 교육 과정으로 잡아가는 듯 하다. 그런데 여러분은 리눅스를 왜 배워야 하는지 생각해본 적이 있는가? 그리 많지는 않을 텐데, 리눅스를 배우는 이유는 크게 다음과 같다.

첫째, 리눅스는 IT 산업 전반에서 쓰는 운영체제이다. 휴대폰, 클라우드 서버, 네트워크 장비는 물론 전기자동차와 IoT 디바이스까지 리눅스를 채택하고 있다.

둘째, 네트웤, 브라우저, WAS 웹 어플리케이션, 보안 유틸리티 등 수많은 프로그램이 리눅스 기반 환경에서 동작한다. 여러분이 리눅스를 알고 싶지 않고 리눅스 사용법을 알고 싶지 않을 수 있더라도 다양한 프로그램을 실행하고 운영하기 위해서는 리눅스를 알아야 한다.

셋째, 리눅스는 오픈소스 기반 운영체제이다. 리눅스는 하드웨어를 제어하는 리눅스 커널과 그 위에서 실행되는 리눅스 유틸리티로 구성돼 있다. 그런데 리눅스 커널은 물론이고 대부분 리눅스에서 실행되는 프로그램의 소스코드는 공개돼 있다.

구체적으로 다음과 같은 기술들이 리눅스 시스템 프로그램이나 리눅스 디바이스 드라어버에 구현돼 있고,

* 운영체제 핵심 기능
* 각종 보안 기술
* 네트워크 패킷 통신
* 각종 센서 드라이버
* 메모리 시스템
* CPU 아키텍쳐(ARM, x86) : 익셉션, 인터럽트, 메모리 관리
* 파일 시스템과 SD 카드

소스코드가 공개돼 있어서 소스코드를 분석함으로써 세부 동작 원리를 파악할 수 있다.

### 리눅스 커널은 왜 배워야 할까?

누군가가 '프로그래머로 일하려면 리눅스를 배워야 한다'라고 말한다면 대부분 수긍할 것이다. 하지만 '리눅스 커널도 배워야 한다'라고 주장한다면 바로 납득하기는 어려울 것이다. 이번에는 '리눅스 커널을 배워야 하는 이유'에 대해 이야기해보려고 한다.

이 책의 주제가 리눅스 커널이긴 하지만 필자는 솔직히 말씀드리고 싶다.

*반드시 리눅스 커널을 배울 필요는 없다.*

임배디드 리눅스나 리눅스 시스템을 개발할 때 '커널 소스'를 읽지 않고도 '리눅스 명령어'를 입력하고 '커널 로그'를 읽으면서 개발할 수도 있다. 커널에 대한 깊이 있는 지식 없이도 개발자로서의 경력을 유지할 수도 있다

하지만 필자는 다음과 같이 말씀드리고 싶다.

*리눅스 고급 개발자 또는 엔지니어로 실력을 인정바고 오랫동안 리눅스 개발을 하고 싶다면 리눅스 커널은 반드시 배워야 한다.*

그럼 '리눅스 커널'을 배워야 하는 이유를 더 자세히 알아보겠다.

첫째, 임베디드 리눅스 혹은 BSP(Board Support Package) 개발자로 디바이스 드라이버 개발을 맡고 있다면 리눅스 커널을 잘 알아야 한다. 그 이유는 간단하다.

*디바이스 드라이버는 커널 함수를 호출하는 방식으로 구현돼 있기 때문이다.*

C 프로그래밍을 잘 하려면 strcpy, strcmp, printf 같은 라이브러리 함수의 용법을 잘 알아야 하듯이 디바이스 드라이버 개발을 잘 하려면 커널이 제공하는 함수의 동작 원리를 파악하고 있어야 한다. 그래서 임베디드 리눅스 혹은 BSP 벤더에서는 '리눅스 커널'을 직무 교육 과정으로 운영하는 경우가 많다.

둘째, 고급 리눅스 시스템 프로그래머가 되려면 리눅스 커널을 알아야 한다.

리눅스 시스템 프로그램은 다음과 같은 함수로 구성돼 있다.

* open(), read(), write(), close() : 파일 처리 관련 함수
* fork(), getpid(), exit() : 프로세스 처리 관련 함수
* sigaction(), pause() : 시그널 처리 관련 함수

이러한 함수를 호출하면 리눅스 라이브러리 함수가 이를 처리할 것이라 생각할 수 있다. 하지만 실제로는 리눅스 라이브러리의 도움으로 POSIX 시스템 콜을 호출해 커널이 동작한다. 한 가지 예를 들어본다.

리눅스 시스템 프로그램으로 open(), read(), write() 함수를 호출했는데 함수에서 에러를 반환했다. 에러 코드를 반환한 주인공은 누구인가? 리눅스 라이브러리인가? 그 주인공은 바로 커널이다. 여기에는 그럴 만한 이유가 있다. 리눅스 시스템 프로그램을 실행하는 주체는 커널이기 때문이다. 따라서 커널을 배우면 리눅스 시스템 프로그램의 세부 동작 원리를 알 수 있다.

셋째, 운영체제의 핵심 원리를 소스코드 분석으로 배울 수 있다. 리눅스 커널은 오픈소스 프로젝트이므로 다음과 같은 커널의 핵심 구현 원리를 소스코드 분석을 통해 배울 수 있다.

* CPU 아키텍쳐(ARM, x86) : 익셉션, 인터럽트, 메모리 관리
* 스케쥴링
* 시스템 콜
* 시그널
* 가상 파일 시스템
* 메모리 관리

우리가 새로운 소프트웨어 기술을 배우는 과정은 크게 두 가지로 생각해볼 수 있다.

* 우선 프로그램을 사용해 본다.
* 코드를 작성하거나 소스코드를 분석해본다.

프로그램을 사용해 본 후 소스코드를 분석해서 구현 방식을 파악하면 더 많은 것을 배울 수 있다. 마찬가지로 커널도 이 방식으로 배울 수 있다. 즉, 커널 디버깅을 통해 '커널을 사용'해보고 커널 소스를 작성하면서 분석할 수 있다. 운영체제 커널을 이론만으로 공부하는 방법보다 더 빨리 실력이 늘 것이다.

넷째, IT 산업을 이루는 제반 기술의 세부 구현 방식을 알 수 있다. 파일 시스템, 메모리 관리, 네트워크, 이더넷 등의 기술들은 커널에서 소스코드로 만날 수 있다.

지금까지 설명한 '리눅스 커널을 배워야 하는 이유'를 한 문장으로 정리하면 다음과 같다.

*고급 리눅스 개발자가 되려면 커널을 배워야 한다.*

## 리눅스의 전망

이번 절에서는 먼저 일반적인 운영체제의 특징을 소개하고 리눅스 운영체제의 점유율을 확인하면서 리눅스의 전망을 알아본다.

### 운영체제란 무엇인가?

운영체제는 알게 모르게 우리 일상 생활의 일부가 된 지 오래이다. 가령 대학생들은 수강 신청을 컴퓨터로 하고 과제도 이메일로 제출한다. 사무직에 종사하는 분들은 대부분 컴퓨터로 일을 한다. 소프트웨어 개발자는 물론이고 다른 사무직에 종사하는 분들도 데스크톱 PC나 노트북으로 업무를 처리한다. 또한 대부분의 사람들이 휴대폰을 하나씩 가지고 다닌다.

그럼 사람들은 컴퓨터와 휴대폰으로 무엇을 하는가? 프로그램을 사용한다. 컴퓨터나 휴대폰으로 게임을 즐기거나 업무 처리를 위해 메일을 읽고 보내기도 한다. 브라우저로 인터넷 서핑을 하고 음악을 듣는다.

그런데 대부분의 사람들은 데스크톱 PC와 휴대폰에서 사용하는 프로그램이 모두 운영체제 위에서 실행되고 있다는 사실은 잘 모른다. 운영체제에는 관심이 없고 운영체제에서 실행되는 애플리케이션에만 관심이 있다. 자, 여기서 한 가지 질문을 해본다.

*여러분 중에서 운영체제를 직접 써 본 분이 있는가?*

대부분 이 질문을 받으면 황당하다고 느낄 것이다. 우리는 운영체제에서 실행되는 애플리케이션을 쓰는 것이지 운영체제를 직접 사용하지는 않는다.

'운영체제'는 하드웨어와 응용 프로그램 사이에 있는 계층이다. 운영체제는 일반 사용자가 '스타크래프트'와 같은 게임이나 브라우저 프로그램이 잘 실행되는 기반 환경을 제공한다.

또한 운영체제는 세부 하드웨어를 관리하는 역할을 수행하는데, 이를 가리켜 '운영체제는 하드웨어를 가상화한다'라고 말한다. 사실 일반 사용자는 휴대폰이나 컴퓨터를 처음 고를 때 화면 크기, CPU 속도나 메모리 용량과 같은 기본적인 스펙에 관심을 기울인다. 하지만 막상 휴대폰이나 컴퓨터를 구입하고 나면 응용 프로그램만 사용하지 세부 하드웨어 부품이나 스펙(CPU 코어나 메모리 대역폭)에 대해 알려고 하지 않는다. 그 이유는 운영체제가 서로 다른 하드웨어 부품을 관리하는 역할을 수행하기 때문이다.

이처럼 일반 사용자는 운영체제에서 돌아가는 '게임'이나 '워드나 엑셀' 같은 응용 프로그램에 관심을 갖지 운영체제에는 관심이 없다. 당연한 이야기지만 '운영체제'에 관심을 둘 필요도 없다.

하지만 일반 사용자가 아닌 개발자인 경우에는 조금 상황이 다르다. 여러분이 작성하는 모든 코드를 실제로 실행하는 주체는 다음과 같이 운영체제 커널이다.

* 유저 애플리케이션 : 리눅스 표준 함수를 호출하면 시스템 콜을 통해 실제로 커널이 동작
* 디바이스 드라이버 : 디바이스 드라이버는 커널이 제공하는 함수를 사용하므로 실제 커널이 동작

따라서 개발자가 작성한 코드의 핵심 동작 원리를 파악하려면 운영체제의 핵심인 커널을 잘 알아야 한다.

여기까지 리눅스 운영 체제의 핵심인 커널을 잘 알아야 하는 이유를 설명했다. 그런데 이 부분까지 읽고 나면 한 가지 의문이 들 수 있다. "이렇게 운영체제의 커널이 중요하다면 학생들에게 이를 배울 기회를 줘야 하지 않을까?"

사실 컴퓨터 공학 관련 학과 전공 필수 과목으로 '운영체제'가 개설돼 있다. 이 책에서 설명하는 프로세스, 스케줄러, 메모리 관리와 같은 리눅스 커널의 개념들은 모두 운영체제 수업에서 다루는 내용이다. 그렇다면 교육 과정으로 운영체제가 개설돼 있다는 사실은 어떤 의미를 내포하는가? 운영체제는 미래의 프로그래머가 될 학생이 필수적으로 알아야 할 내용이라서 전공 수업으로 정하지 않았을까?

이어지는 절에서는 우리가 실행활에서 어떤 운영체제를 사용하고 있는지 살펴본다.

### 우리는 어떤 운영체제를 쓰고 있나?

우리가 알지 못하는 사이 리눅스는 우리 생활의 구석구석에 쓰이고 있다. 이번 절에서는 다음과 같은 분야에서 리눅스 운영체제가 차지하는 점유율을 알아본다.

* 데스크톱(개인용 컴퓨터)
* 모바일(휴대폰)
* 슈퍼 컴퓨터

#### 데스크톱(개인용 컴퓨터)

72~90%의 점유율을 보이는 운영체제가 마이크로소프트 '윈도우 NT 계열' 운영체제이다. 78%의 점유율로 부동의 1위를 지키고 있다. 그 다음으로는 iOS가 16%, 리눅스가 2%의 점유율을 보인다. 유닉스 계열 운영체제로 분류되는 IOS와 리눅스 운영체제를 합쳐도 15%밖에 되지 않는다.

> 보통 iOS와 리눅스를 합쳐 유닉스 계열 운영체제라고 부른다.

일반인이 많이 쓰는 데스크톱 PC 기기의 경우 리눅스의 점유율은 저조하다. 즉, '윈도우가 대세다'라고 말할 수 있다. 그래서 이 데이터를 보고 나면 이렇게 불평할 수도 있다.

*리눅스 운영체제는 거의 안 쓰는데 왜 배워야 할까?*

어느 정도 일리가 있는 의견이다. 운영체제를 쓰는 기기가 데스크톱 PC로 한정돼 있다면 말이다. 하지만 시선을 모바일 기기로 돌려보면 이야기가 달라진다.

모바일 기기에서 리눅스 기반 안드로이드는 76%, 아이폰 등에서 쓰이는 iOS는 22%의 점유율을 보인다. 유닉스 계열로 분류되는 iOS와 안드로이드를 합친 점유율이 98%에 육박한다.

일상 생활의 필수품으로 자리잡은 휴대폰의 경우 유닉스 계열 운영체제가 시장을 지배하고 있다. 특히 안드로이드는 리눅스에서 가장 인기 있는 배포판으로, 많은 개발자들이 안드로이드 리눅스 개발에 참여하고 있다.

#### 슈퍼컴퓨터

이번에는 슈퍼컴퓨터에서 어떤 운영체제를 쓰고 있는지 알아본다.

거의 100% 점유율로 슈퍼컴퓨터에서는 리눅스 운영체제를 쓰고 있다. 이 밖에 70% 이상의 웹 서버에서도 리눅스를 사용하고 있으며, 라우터나 태블릿 같은 IT 기기에서도 리눅스를 많이 사용하고 있다.

이번 절에서 다룬 내용을 정리하면 다음과 같다.

**데스크톱 PC를 제외한 모바일, 슈퍼컴퓨터를 포함한 기기에서는 리눅스 계열 운영체제를 많이 쓰고 있다.**

> 여기까지 우리의 실행활에서 리눅스란 운영체제를 얼마나 사용하는지 살펴봤다. 이번에는 이번 절에서 설명한 내용들을 뒷받침할 수 있는 신문(금융 IT) 기사 중 일부 내용을 소개한다.
>
> 리눅스 운영체제 배포판은 스마트 폰, TV, 디지털 비디오 레코더, 항공 엔터테인먼트 시스템, 자동차 제어 시스템, 라우터, 스위치 등에 적용됐다. 현재 어디서나 리눅스 커널 기반 시스템을 만날 수 있으니, 리눅스가 가장 지배적인 운영체제라고 볼 수 있다.
>
> 출처 : https://newsroom.koscom.co.kr/17371

## 리눅스의 역사

'무료 유닉스 계열 운영체제'를 표방하는 리눅스가 탄생하는 과정을 살펴보고 리눅스가 인기 있는 운영체제로 발전한 이유를 알아본다.

### 유닉스의 탄생

리눅스의 역사를 알기 위해서는 먼저 유닉스의 탄생 과정을 살펴볼 필요가 있다. 리눅스의 모태는 유닉스이기 때문이다.

컴퓨터가 발명된 후 컴퓨터는 한동안 한 가지 프로그램만 실행했다. 가령 음악 CD를 재생하는 컴퓨터가 있다고 하면 오직 CD만 재생하는 프로그램만 실행하는 식이다.

시간이 흘러 컴퓨터는 1개 이상의 프로그램을 실행할 수 있는 수준으로 컴퓨팅 속도가 빨라진다. 이런 상황에서 컴퓨터 공학자들은 뭔가 새로운 소프트웨어를 만들어 보려는 시도를 하게 되는데, 이 프로젝트가 바로 유닉스의 모태가 된 '멀틱스' 운영체제이다.

#### 멀틱스 운영체제

1965년 MIT, AT&T 벨 연구소, 제너럴 일렉트릭(General Electric) 소속 개발자들이 모여 멀틱스(Multics)라는 운영체제를 개발하기 시작했다. 이 중에는 '켄 톰슨'과 '데니스 리치' 같은 컴퓨터의 역사를 바꾼 전설적인 프로그래머도 있었다. 이들이 구현하고자 하는 운영체제의 핵심 기능은 다음과 같았다.

*멀티태스킹을 지원하는 운영체제를 구현하자!*

4차 산업혁명 시대를 맞이하는 현 시점에서 보면 멀티태크킹은 운영체제의 기본 기능이다. 하지만 1960년대 중반에는 혁신적인 기능이었다. 당시 소프트웨어 기술로는 한 개의 제품에서는 하나의 소프트웨어만 실행할 수 있는 수준이었기 때문이다.

여러 가지 노력에도 불구하고 멀틱스 운영체제는 목표를 이루지 못하고 좌초되고 만다. 하지만 멀틱스 프로젝트에 투입됐던 켄 톰슨과 다른 개발자들은 다음과 같은 목표를 위해 지속적으로 운영체제 연구에 몰두한다.

*멀티태스킹과 멀티 유저를 지원하는 운영체제를 개발하자.*

이 과정에서 탄생한 것이 바로 유닉서(UNIX)이다. 유닉스 운영체제는 어셈블리어를 사용해 구현했는데, PDP-7란 소형 컴퓨터에서만 실행됐기에 호환성이 없다고 볼 수 있었다. 그래서 다른 기종의 CPU가 탑재된 컴퓨터에서 유닉스를 쓰려면 해당 기종에 맞는 어셈블리어로 새롭게 코드를 작성해서 새로운 CPU 아키텍쳐에 맞는 유닉스 운영체제를 구현해야 했다. 다음과 같은 상황이다.

*드디어 유닉스 커널을 완성했다. 이제 이 어셈블리 코드를 다른 CPU 어셈블리 명령어로 바꿔서 유닉스 커널을 개발해 볼까?*

*전체 유닉스 커널 어셈블리 코드를 다른 CPU 아키텍쳐에서 구동하는 어셈블리 명령어로 바꾸라고?*

즉, 유닉스를 완성한 시점에서 모든 유닉스 어셈블리 코드를 새로운 CPU 아키텍처에 맞게 모두 바꿔야 했다.

현재 시점으로 바꿔서 x86 어셈블리 명령어로 구현된 리눅스의 전체 소스코드를 ARMv8 명령어로 '모두' 바꿔서 개발해야 하는 것과 동일하다.

#### 1973년 : 최초의 유닉스가 완성되다

유닉스의 호환성 문제를 개선하고자 데니스 리치는 아예 새로운 프로그래밍 언어를 개발하기로 결심한다. 이 프로그래밍 언어의 이름은 C 언어이다. C 언어 개발을 완성한 후 어셈블리 명령어로 구현됐던 유닉스를 C 언어로 작성해 새로운 버전의 유닉스를 개발하게 된다.

C 언어의 등장으로 유닉스 개발에 속도가 붙게 됐고, 이에 발맞춰 대학과 연구기관에 소속된 개발자들이 유닉스 기능을 구현하게 된다. 유닉스는 여러 기기에서 실행할 수 있는 호환성과 이식성을 갖추게 됐다. 시간이 흘러 유닉스는 제품으로 상용화할 수 있는 수준의 운영체제로 발전한다.

여기까지가 유닉스의 중반기 시절이다. 유닉스가 빠른 속도로 완성도가 높아진 이유는 무엇일까?

*첫째, 유닉스는 오픈소스로서 소스코드를 무료로 대학기관이나 연구소에 배포했다.*

처음에는 대학 기관에서 운영체제의 원리를 학습하고 연구하려는 목적으로 유닉스의 소스코드를 분석했다. 하지만 대학 기관과 연구소에 소속된 개발자들은 소스코드 분석에서 한걸음 나아가 유닉스 코드를 개선하면서 유닉스 프로젝트에 기여하게 됐다.

*둘째, C 언어의 도입으로 유닉스의 이식성과 호환성을 높였다.*

초창기 유닉스는 모든 소스를 어셈블리 명령어로 작성했다. 그래서 유닉스가 특정 CPU 아키텍쳐에서만 작동할 수 있었다. 그런데 데니스 리치가 만든 C 언어로 유닉스를 개발하면서 어셈블리 명령어에 비해 이식성과 호환성을 높일 수 있게 됐다.

유닉스는 발전을 거듭해 다양한 버클리 유닉스(Berkeley Unix; BSD), SYSV 계열로 분화되어 현재까지 리눅스와 더불어 다양한 유닉스 계열 운영체제가 사용되고 있다.

#### 1984년 : 유닉스 유료화에 대한 반발로 GNU 단체가 설립되다

앞에서 설명한 바와 같이 유닉스는 AT&T 회사의 벨 연구소에서 개발했다. 그러던 AT&T가 전화기를 비롯해 전자 및 컴퓨터 사업까지 사업 영역을 넓히다 보니 규모가 커졌다.

AT&T가 거대 기업이 되다 보니 모든 미국 졸업생은 AT&T로 몰려들게 되고 미국도 AT&T에 의존하게 됐다. 이런 상황에서 AT&T는 '반독점 소송'을 당하고 패소하게 된다. 1984년에 이르러 미국 법원은 다음과 같은 결정을 내린다.

*AT&T란 거대 기업을 7개 회사로 나누자.*

그 7개 회사 중에서도 지금도 유명한 버라이즌, 루슨트 등등이 있다. 이 과정에서 AT&T에 다음과 같은 판결을 내린다.

*AT&T는 컴퓨터 사업에 손 대지 말아라!*

미국 법원에서 이런 판결을 내리자 AT&T는 수년 동안 유닉스를 개발하고도 이를 컴퓨터 제품으로 만들 수 있는 개발 인프라를 구축할 수 없게 된다. 그래서 유닉스를 연구할 필요가 없어졌다. 그래서 AT&T는 유닉스를 돈을 받고 팔게 된다.

그런데 유닉스를 여러 회사에 팔다 보니 유닉스의 변종들이 생겨났다. 그래서 '유닉스에 대한 표준을 맞춰 보자'라고 해서 POSIX라는 규격이 만들어진다. 이후 여러 유닉스 벤더들은 POSIX 규약에 맞춰 호환성을 유지한 유닉스 제품을 개발하게 된다.

그런데 유닉스 개발에 참여했던 대학이나 연구기관은 더 이상 무료로 유닉스 소스코드를 볼 수 없게 됐다. 오로지 AT&T에게서 유닉스를 구매한 컴퓨터 업체의 개발자들만 유닉스 소스코드를 분석하면서 개발할 수 있게 된 것이다. 그래서 기존 유닉스 개발에 참여했던 연구원들은 불맞을 갖기 시작한다.

이런 유닉스의 유료화에 반기를 들고 새로운 무료 버전의 유닉스를 만들어보자는 움직임이 일어난다. 돈을 내고 유닉스를 만드는 것이 아니라 무료 버전의 유닉스를 개발하자는 목표로 다음과 같은 단체를 설립한다.

*GNU(GNU is not  UNIX) : GNU는 유닉스가 아니다.*

GNU라는 단체가 FSF(Free Software Foundation) 재단을 설립하면서 무료 유닉스 개발에 착수한다. GNU는 리처드 스톨만을 중심으로 설립됐는데 시간이 흘러 수백만 명이 참여하는 프로젝트로 규모가 커졌다. 그래서 유닉스 유틸리티와 같은 유닉스 기능을 다시 구현하게 됐는데 기존의 유닉스보다 더 완성도 높은 코드로 만들어지게 된다. 이처럼 유닉스 유틸리티를 하니씩 구현하면서 유닉스를 구성하는 소프트웨어를 만들기 시작한다.

유닉스라는 프로그램을 구조적 관점에서 보면 유닉스를 구동하는 핵심 코어인 유닉스 커널이 있고, 그 위에서 실행되는 유닉스 유틸리티가 있다. 유닉스 유틸리티는 여러 개발자들이 모여 어느 정도 완성도를 높여서 개발했다. 그런데 문제가 생겼다. 유닉스 커널을 제대로 만들기가 어렵다는 것이다. 그래서 한동안 유닉스 커널 개발이 정체된다.

#### 1992년 : AT&T와 BSD 간의 유닉스 소송

그런데 GNU에서만 무료 유닉스 개발을 시도한 것이 아니었다. 유닉스가 개발되던 초기에는 유닉스 코드를 대학 연구소에 배포했다. 그중 UC 버클리에 속한 BSD(Berkely Software Distribution) 개발자들이 기존 유닉스 코드를 재해석해서 1989년 후반 유닉스 커널을 포함한 무료 유닉스를 완성한다.

BSD 개발자는 AT&T에서 배포한 유닉스 코드를 다시 작성해서 'Net/1'이라는 이름으로 무료로 소스코드를 배포하게 된다. 이후 1991년에는 코드 완성도를 높여서 'Net/2'를 공개한다. 그런데 1992년 AT&T는 UC 버클리에 소송을 걸게 된다. 소송의 이유는 다음과 같다.

*AT&T 내부 자료를 이용해 배포한 BSD 유닉스인 Net/2는 AT&T의 저작권을 침해했다.*

1992년부터 시작된 AT&T와 BSD 간의 소송을 '유닉스 전쟁'이라고 부르기도 한다. 소송은 1994년까지 진행됐는데, AT&T USL(Unix Syste Laboratory)이 노벨에 팔린 후에 AT&T는 소송을 취하하게 된다.

소송이 진행되는 동안 US 버클리에서 BSD 유닉스 개발은 정체되고 만다.

### 1991년 : 리누스 토발즈의 등장

비슷한 시기에 무료 유닉스를 만들고자 하는 움직임이 있었다. 그 주인공은 리누스 토발즈이다. 핀란드의 헬싱키 대학에 재학 중이던 리누스 토발즈는 GNU 시스템에 적합한 커널을 직접 개발하기 시작해서 1991년 8월 25일 GNU 커널을 어느 정도 완성한 다음 comp.os.minix 라는 뉴스그룹에 다음과 같은 글을 올린다.

```
From: torvalds@klaava.Helsinki.FI (Linus Benedict Torvalds)
Newsgroups: comp.os.minix
Subject: What would you like to see most in minix?
Summary: small poll for my new operating system
Message-ID:
Data: 25 Aug 91 20:57:08 GMT
Organization: University of Helsinki

Hello everybody out there using minix -
I'm doing a (free) operating system (just a hobby, won't be big and professional like gnu) for 386(486) AT clones. This has been brewing since april, and is starting to get ready. I'd like any feedback on things people like/dislike in minix, as my OS resembles it somewhat(same physical layout of the file-system (due to practical reasons) among other things).

I've currently ported bash(1.08) and gcc(1.40), and things seem to work. This implies that I'll get something practical within a few months, and I'd like to know what features most people would want. Any suggestions are welcom, but I won't promis I'll implement them :-)
```

위 글의 핵심은 다음과 같다.

*GNU 무료 운영체제를 개발 중인데, 인텔 칩 i386에서 구동된다.*

그런데 초기 버전인 0.01은 지금과 비교하면 정말 기본적인 커널 기능만 지원했다. 또한 실행도 되지 않았다. 그 후 0.02 공식 버전을 발표했는데, BASH(GNU Bourne Agin Shell)와 GCC(GNU C 컴파일러) 정도만 실행 가능한 수준이었다. 이듬해 3월, 리눅스는 0.95로 버전이 업그레이드됐고 다음과 같은 기능을 지원했다.

* 인텔 x86 칩에서 그래픽 사용자 인터페이스를 추가

그런데 그 당시 스톨만과 FSF 단체는 허드(Hurd)를 GNU 커널로 개발하고 있었다. 생각보다 허드 개발이 진척되지 않아 고민 끝에 다음과 같은 결정을 내린다.

*리누스 토발즈가 개발한 유닉스 커널을 GNU 커널로 채택하자.*

이 과정에서 탄생한 것이 리눅스이며, 기존 GNU 유틸리티와 커널이 결합해 GNU는 완성된 구조를 이루게 됐다.

#### 리눅스가 인기 있는 이유는 무엇일까?

GNU 리눅스 프로젝트에서 시작된 리눅스는 현재 가장 널리 쓰이는 운영체제로 발전했다. 그렇다면 리눅스가 윈도우와 함께 전 세계에서 쓰이는 이유는 무엇인가?

첫째, 누구나 소스코드를 볼 수 있다.

리눅스는 크게 리눅스 커널과 그 위에서 실행되는 리눅스 유틸리티로 구성돼 있다. 그런데 커널은 물론 리눅스를 구성하는 대부분의 유틸리티 프로그램은 오픈소스이다. 그래서 누구나 리눅스 커널과 리눅스 유틸리티 소스코드를 받아서 분석할 수 있다. 또한 소스코드를 누구나 읽을 수 있다는 것은 전 세계의 모든 개발자가 같은 조건에서 리눅스를 익힐 수 있다는 의미이다.

둘째, 개방적인 오픈소스 프로젝트다.

리눅스의 가장 큰 매력은 누구나 리눅스 프로젝트에 참가해 자신이 작성한 코드를 배포할 수 있다는 점이다. 리눅스 소스코드를 분석하다거나 버그나 논리적인 오류가 있으면 누구나 자신의 소스코드를 리눅스 오픈소스 프로젝트에 반영할 수 있다. 또는 가독성이 떨어지는 코드를 리팩터링(Refactoring)한 코드를 반영할 수도 있다.

누구나 소스코드를 볼 수 있을뿐더러 프로젝트에 기여할 수도 있으니 개방적인 옾느소스 프로젝트라고 말할 수 있다.

셋째, 리눅스 커뮤니티의 힘이 막강하다.

리눅스는 각 기능마다 메일링 리스트를 통해 전 세계 개발자들이 다음과 같은 주제로 치열한 토론을 벌인다.

* 커널 버그
* 커널 개선 패치

리눅스에 어떤 버그가 있으면 커뮤니티를 통해 빠른 시간 내 논의되며, 전 세계 개발자들이 서로 버그를 해결하는 패치를 제안하면 토론한다.

넷째, 다양한 CPU 아키텍쳐를 지원한다.

리눅스는 다양한 CPU 아키텍쳐를 지원하도록 설계돼 있다. CPU 아키텍쳐에 맞춰 리눅스를 빌드하면 리눅스를 실행할 수 있다.

## 리눅스는 어디에 쓰일까?

리눅스는 윈도우와 함께 우리의 일상 생활과 떼려야 뗄 수 없는 관계에 있는 운영체제입니다. 리눅스는 휴대폰, TV, 클라우드 서버에서 전기자동차에 이르기까지 곳곳에 쓰이고 있다. 4차 산업 혁명의 시대를 맞이해서 리눅스는 그 저변을 계속 확대하고 있다. 이번 절에서는 이처럼 우리 사회에 자리 잡은 리눅스란 운영체제를 어디에 쓰는지 좀 더 구체적으로 살펴본다.

### 안드로이드

리눅스는 휴대폰 운영체제로 이미 자리를 잡았다. 대표 주자인 안드로이드는 2010년부터 현재까지 스마트폰의 주력 운영체제로 쓰이고 있다. 

리눅스 커널은 안드로이드의 핵심 요소이다. 그림 1.5와 같이 안드로이드는 리눅스 커널 위에서 동작하므로 구글의 안드로이드 개발자는 리눅스 커널을 안드로이드 시나리오에 맞게 수정해서 쓰고 있다.

처음 휴대폰용으로 개발했던 안드로이드는 TV와 자동차용 플랫폼으로 영역을 확장하고 있다.

#### 자동차(AutoMotive)

리눅스는 휴대폰에서만 쓰는 운영체제가 아니다. 리눅스 저변은 휴대폰에서 자동차로 확대되고 있다.

최근에 전기자동차 시장이 열리면서 자동차 인포테인먼트(Infotainment) 분야에 리눅스 커널이 활발히 쓰이고 있다. 인포테인먼트란 자동차의 내비게이션 기능에서 운전자에게 제공하는 다양한 멀티 미디어 서비스를 의미한다.

제니비(GENIVI Alliance) 같은 자동차 기본의 인포테인먼트(IVI)와 커넥티비티 소프트웨어 플랫폼을 위한 단체가 설립됐으며 지속적으로 그 영역을 확대할 것으로 예상한다.

### 사물인터넷 디바이스

대부분의 IoT 및 임베디드 디바이스는 다양한 리눅스 상에서 구현되고 있다. 각종 센서와 전자 명함, 전자 메뉴판과 같은 더 많은 IoT 디바이스들이 앞으로 등장할 것이며, 이를 위해 리눅스 기술에 계속 관심이 모아질 것이다.

엔비디아나 인텔, 퀄컴 같은 대형 SoC 벤더들도 자사의 강점을 살려 IoT 시장에 뛰어들고 있다. IoT 임베디드 리눅스 개발을 위한 욕토 프로젝트(Yocto Project) 같은 단체가 만들어져서 다양한 리눅스 배포판 생성을 가능하게 하는 도구를 만들고 있다.

이 밖에도 TV, 클라우드 서버, 슈퍼컴퓨터 등 수많은 기기에서 리눅스 운영체제가 실행되고 있다. 앞으로 리눅스는 5G 및 AI 기술과 결합해 더 많이 활용될 것이라 예상한다. 

## 임베디드 리눅스 개발 단체

임베디드 리눅스는 여러 단체가 협업한 결과물이다. 각 단체의 역할을 알아본다.

### 리눅스 커널 커뮤니티

우리가 접하는 대부분의 리눅스 커널 코드는 리눅스 커널 커뮤니티에서 만들어진다. 리눅스 커널 커뮤니티는 리눅스 커널 개발의 심장으로서, 리눅스 커널 자체의 알고리즘을 비롯해 논리적 오류나 문제점을 개선하는 패치를 논의하고 관리한다.

* 버그 수정 패치
* 코드 리팩터링
* 신규 알고리즘
* 문서화

보통 2주 간격으로 그렉 크로아 하트만이라는 개발자가 메일로 전 세계 개발자들에게 패치 반영 사실을 통지한다.

리눅스 커널 버전과 코드 내역은 리눅스 커널 아카이브(https://www.kernel.org/) 사이트에서 확인할 수 있다.

![image-20240302213146708](.\assets\image-20240302213146708.png)

그림 1.8에서 왼쪽 부분을 보면 'longterm'으로 표시된 부분이 보인다. 이는 안정화된 리눅스 커널 버전을 의미한다. 이처럼 리눅스 커널 커뮤니티에서 관리하는 안정화된 리눅스 커널 버전을 LTS라고 부른다. 최신 리눅스 커널 버전에 적용된 버그 수정 패치는 LTS 리눅스 커널 버전에 꾸준히 반영된다.

SoC 업체들은 대부분 이 LTS 리눅스 커널 버전을 선택해 개발한다. 이 책에서 사용할 라즈비안 배포판도 LTS 리눅스 커널을 탑재했다.

### CPU 벤더

리눅스 커널과 관련된 다른 주요 단체로 CPU 벤더가 있다. CPU 벤더는 CPU를 설계하는 회사를 뜻하며, 대표적인 업체는 다음과 같다.

* ARM(ARMv7/ARMV8)
* 인텔(x86)
* IBM(PowerPC)

CPU 벤더도 리눅스 커널 개발에 참여한다. 다음과 같은 리눅스 커널의 핵심 기능은 CPU에 따라 구현 방식이 다르기 때문이다.

* 시스템 콜
* 익셉션
* 컨텍스트 스위칭

![image-20240303013707834](.\assets\image-20240303013707834.png)

보다시피 리눅스 커널은 다양한 CPU 아키텍처와 함께 구동된다. 그런데 커널의 핵심 동작은 서로 다른 CPU 어셈블리 코드로 구현돼 있다. 컨텍스트 스위칭의 세부 동작은 x86이나 ARMv7 같은 CPU별로 구현 방식이 다르다.

리눅스의 구조는 위와 같은데 라즈비안과 같이 ARMv7 기반 리눅스 커널을 쓰려면 어떻게 해야 할까? ARMv7에 맞는 빌드 스크립트로 커널을 빌드하면 된다. 즉, 리눅스 커널은 다양한 CPU 아키텍처를 지원하는 소스 트리를 갖추고 있으며 사용하고자 하는 CPU 아키턱처에 맞춰 빌드하면 이에 맞는 커널 이미지를 생성할 수 있다.

### SoC 벤더

SoC는 System-on-chip의 약자로 하나의 컴퓨터 또는 다른 전자 시스템들의 모든 구성 요소를 통합한 직접회로를 의미한다. SoC를 개발하는 업체인 브로드컴, 삼성전자, 퀄컴, 인텔, 미디어텍, 엔비디아 같은 회사를 SoC 벤터라고 부른다. 이들은 먼저 리눅스 커널 버전을 선택한다. 그리고 CPU 벤더로부터 툴 체인을 받아 자신의 SoC 스펙에 맞게 리눅스 커널 코드를 수정하거나 드라이버를 추가한다.

SoC 벤터에서 개발하는 제품명은 아래와 같다.

* 브로드컴 : BCM(bcm2837, 라즈베리 파이에 탑재)
* 삼성전자(시스템 LSI) : 엑시노스(Exynos)
* 퀄컴 : 스냅드래곤
* 인텔 : 아톰, 무어필드
* 미디어텍 : 헬리오
* 엔비디아 : 테그라

SoC 벤더에서 개발하는 리눅스의 전체 구조는 다음과 같다.

![image-20240303014411625](.\assets\image-20240303014411625.png)

그림 1.10에서 가장 오른쪽 윗부분 박스에서 볼 수 있듯이 리눅스 커널을 사용해 SoC 하드웨어를 제어하는 디바이스 드라이버를 작성한다. 예를 들면, 엔비디아 SoC와 퀄컴 SoC의 CPU(Graphics Processing Unit)는 자사의 SoC 하드웨어에 맞게 설계돼 있으니 서로 다른 디바이스 드라이버가 있는 것이다.

### 보드 벤더 및 OEM

보드 벤더와 OEM(Original Equipment Manufacturer) 업체는 SoC가 릴리즈한 리눅스 커널 코드를 받아 제품 스펙과 시나리오에 맞게 제품을 개발한다. 여기서 '보드 벤더 및 OEM'은 무엇을 의미하는가?

보드 벤더는 라즈베리 파이 재단과 같은 업체이고 OEM은 삼성전자, LG전자와 같이 상용 제품을 개발하는 업체를 뜻한다.

이해를 돕기 위해 한 가지 예스를 들어본다. 라즈베리 파이는 BCM2837이라는 SoC를 탑재한 교육용 보드이며 라즈베리 파이 재단에서 개발한다. 여기서 보드 벤더인 라즈베리 파이 재단은 SoC 벤더인 브로드컴이 릴리즈한 리눅스 커널 코드를 받아 라즈베리 파이의 스펙과 시나리오에 맞게 범용 보드로 개발하는 것이다.

많은 개발자들은 이 단계에서 SoC에서 제작한 리눅스 드라어버 코드(리눅스 커널 + SoC 드라이버)를 받아 임베디드 리눅스를 개발한다.

![image-20240303015026265](.\assets\image-20240303015026265.png)

제품마다 다양한 시나리오와 컨셉이 있을 수 있다. 만약 제품 컨셉이 카메라이면 카메라 센서를 제어하는 드라이버를 제작하고, 자동차 내비게이션이면 그래픽 드라이버를 개발할 것이다.

'보드 벤더 및 OEM' 개발자들은 이 과정에서 SoC 업체와 협업할 때가 많다. 만약 SoC 벤더에서 작성한 드라이버에서 버그를 확인하면 '보드 벤더 및 OEM' 업체는 버그를 리포트하고 개선 패치를 받아 수정하는 경우가 많다.

그런데 간혹 '보드 벤더 및 OEM' 업체의 개발자가 SoC 벤더에서 작성한 드라이버에 있는 버그를 직접 수정하는 경우가 있다. SoC 벤더에서 작성한 드라이버 코드는 리눅스 커널 소스코드와 함께 배포하므로 누구나 소스코드를 열어 볼 수 있다. 그래서 자신이 작성하지 않은 리눅스 드라이버 코드를 수정할 수 있는 것이다. 

## 임베디드 리눅스 개발을 잘 하려면 무엇을 알아야 할까?

좁게 보면 임베디드 리눅스 개발자가 알아야 할 지식은 다음과 같다.

* 디바이스 드라이버
* 리눅스 커널
* CPU 아키텍처
* SoC

조금 넓게 보면 다음과 같은 내용도 알면 좋다.

* 유저 공간 HAL(Hardware Abstraction Layer) 코드 구현
* 빌드 스크립트 구현
* 테스트용 디바이스 드라이버 구현
* Git과 형상 관리

### 디바이스 드라이버

임베디드 리눅스 개발을 시작하면 바로 디바이스 드라이버 업무를 맡는 경우가 많다. 물론 프로세스나 회사 규모에 따라 드라이버 개발 범위가 다르다. 제품을 구성하는 디바이스 드라이버의 특정 분야를 맡을 수도 있고, 한 명의 임베디드 개발자가 임베디드 리눅스를 책임지는 경우도 있다.

디바이스 드라이버의 시나리오와 제어하는 하드웨어의 종류는 다양하지만 다음 내용 정도는 알아야 한다.

* 인터럽트 핸들러 함수와 인터럽트를 처리하는 방식
* 디바이스 파일로 open/read/write 연산에 대한 함수를 등록하는 방법
* 디바이스 트리를 읽어 디바이스 속성을 저장하는 방식

디바이스 드라이버 코드를 빨리 읽고 이해하는 능력을 키우는 것도 중요하다.

### 리눅스 커널

디바이스 드라이버는 리눅스 커널에서 제공하는 함수로 구성돼 있다. 호출한 함수의 동작 방식을 알려면 자연히 리눅스 커널 코드를 분석할 수밖에 없다. "리눅스 디바이스 드라이버는 리눅스 커널 그 자체"라고 말하기도 한다.

또한 디바이스 드라이버를 개발하는 과정은 코드를 입력해 드라이버를 구현하는 데 그치지 않는다. 인증 테스트 부서를 통해 드라이버 안정화 테스트 과정을 거친다. 이 과정에서 다양한 버그나 문제 증상이 리포트된다. 카메라 디바이스의 경우 사진을 찍은 후 저장한 화면이 모두 검은색일 수도 있다. 또한 디바이스의 경우 화면이 깨질 수 있다. 이 과정에서 접하는 다양한 버그를 수정해 문제를 해결하기 위해서는 리눅스 커널을 잘 알아야 한다.

### CPU 아키텍처

리눅스 커널의 핵심 개념들은 대부분 어셈블리 코드로 구현돼 있다. 그 이유는 리눅스 커널의 핵심 동작은CPu 아키텍처와 연관된 부분이 많기 때문이다. 예를 들면 다음과 같다.

* 컨텍스트 스위칭
* 익셉션 벡터
* 시스템 콜
* 시그널 핸들러
* 메모리 관리(MMU)

CPU 아키텍처 세부 동작 원리와 어셈블리 코드를 깊게 공부하기보다는 먼저 리눅스 시스템과 커널 로그, ftrace에 친숙해져야 한다.

그런데 리눅스 커널을 좀 더 깊게 알고자 하면 CPU 아키텍처(ARM, x86)에 대해 다음과 같은 내용을 알아야 한다.

* 어셈블리 언어
* 익셉션이 발생하는 원리와 익셉션 벡터의 세부 동작
* 함수 호출 규약(Calling Convention)

### 빌드 스크립트와 Git

앞에서 소개한 빌드 스크립트를 잘 이해하고Git(https://git-scm.com/)을 잘 다루면 효율적으로 개발할 수 있다. 다른 업체가 개발한 드라이버나 응용 프로그램을 현재 사용 중인 소스 트리에 추가해야 할 때가 있다. 이때를 대비해 빌드 스크립트와 빌드 구조를 잘 파악해두어야 한다. 

임베디드 및 BSP 리눅스 개발자가 갖춰야 할 기본 소양은 디바이스 드라이버와 커널에 대한 이해이다.

## 라즈베리 파이와 리눅스 커널

### 라즈베리 파이 실습 보드

라즈베리 파이 3 모델 B의 기본 하드웨어 스펙

* SoC : Broadcom BCM2837 SoC
* CPU : 1.2GHz ARM Cortex-A53 MP4
* GPU : Broadcom VideoCore 4 MP2 400 MHz
* 메모리 : 1GB LPDDR2
* SD카드 : Micro SD, push-pull type

### 리눅스 커널 버전

라즈비안 리눅스 커널의 코드는 라즈베리 파이 깃허브에서 확인할 수 있다.

* https://github.com/raspberrypi/linux/tree/rpi-4.19.y

라즈비안에서만 실행되는 디바이스 드라이버를 제외하고는 라즈비안 커널 소스는 리눅스 커널 커뮤니티 소스와 99% 같다. 

### 라즈비안 버전

### ARM 아키텍처

## 정리

1. 리눅스 커널을 반드시 배워야 한다.
2. 리눅스는 광범위하게 사용되고 있으며, 그 저변은 계속 확대되고 있다.
3. 임베디드 리눅스 개발자들은 대부분 SoC 벤더에서 제공한 드라이버 코드를 토대로 제품을 개발한다.
4. 디바이스 드라이버, 리눅스 커널, CPU 아키텍처, 빌드 스크립트, Git을 기본적으로 알아야 한다.

# 라즈베리 파이 설정

이번 장에서 다룰 내용

* 라즈베리 파이 설치
* 라즈베리 파이에서 커널 빌드와 설치
* 바이너리 유틸리티 사용법
* 라즈베리 파이 사용 시 주의사항

라즈베리 파이에서 커널의 세부 동작을 알려주는 ftrace와 커널 로그를 열어 보면서 커널 동작을 디버깅하면 빠르게 리눅스 커널을 익힐 수 있다.

## 라즈베리 파이란?

실전 개발에서도 다양한 데모용 디바이스로 자주 활용되고 있다.

장점은 다음과 같다.

#### 막강한 커뮤니티

*"리눅스 교육용 보드는 라즈베리 파이가 대세다."*

#### 저렴한 가격

#### 간단한 설치

라즈베리 파이 커뮤니티에서는 라즈베리 파이를 구동할 수 있는 다양한 이미지를 배포한다.

#### 최신 리눅스 커널을 지원

라즈비안 리눅스 커널 버전이 안드로이드 리눅스 커널 버전보다 최신 버전이다. 이처럼 라즈비안은 상용 리눅스 제품보다 더 업그레이드된 리눅스 커널에서 작동한다.

## 라즈베리 파이 설정

### 라즈베리 파이 실습을 위한 준비물

### 라즈베리 파이 설치

#### 라즈비안 이미지 다운로드

#### 라즈비안 이미지를 굽는 방법

### 라즈베리 파이 기본 설정

## 라즈베리 파이 커널 빌드

### 라즈비안 커널 소스코드 내려받기

리눅스 유틸리티 프로그램 설치

```
sudo apt-get install git bc bison libssl-dev
```

라즈비안 최신 커널 소스 내려받기

```
sudo git clone --depth=1 https://github.com/raspberrypi/linux
```

브랜치 확인

```
git branch
```

### 라즈비안 리눅스 커널 빌드

아래 라즈베리 파이 홈페이지에 가면 커널을 빌드하는 방법을 확인할 수 있다.

* https://www.raspberrypi.org/documentation/linux/kernel/building.md

커널 빌드 설정

```
cd linux
KERNEL=kelnel7
make bcm2709_defconfig
```

본격적으로 커널 빌드 진행

```
make -j4 zImage modules dtbs
sudo make modules_install
sudo cp arch/arm/boot/dts/*.dtb /boot/
sudo cp arch/arm/boot/dts/overlays/*.dtb* /boot/overlays/
sudo cp arch/arm/boot/dts/overlays/README /boot/overlays/
sudo cp arch/arm/boot/zImage /boot/$KERNEL.img
```

커널 빌드 스크립트 

***build_rpi_kernel.sh***

```sh

#!/bin/bash

echo "configure build output path"

KERNEL_TOP_PATH="$( cd "$(dirname "$0")" ; pwd -P )"
OUTPUT="$KERNEL_TOP_PATH/out"
echo "$OUTPUT"

KERNEL=kernel7
BUILD_LOG="$KERNEL_TOP_PATH/rpi_build_log.txt"

echo "move kernel source"
cd linux

echo "make defconfig"
make 0=$OUTPUT bcm2709_defconfig

echo "kernel build"
make 0=$OUTPUT zImage modules dtbs -j4 2>&1 | tee $BUILD_LOG
```

```

#!/bin/bash

echo "configure build output path"

KERNEL_TOP_PATH="$(pwd)"
OUTPUT="$KERNEL_TOP_PATH/out"
echo "$OUTPUT"

KERNEL=kernel7
BUILD_LOG="$KERNEL_TOP_PATH/rpi_build_log.txt"

echo "move kernel source"
cd linux

echo "make defconfig"
sudo make 0=$OUTPUT bcm2709_defconfig

echo "kernel build"
sudo make 0=$OUTPUT zImage modules dtbs -j4 2>&1 | tee $BUILD_LOG
```

파일에 실행 권한 부여

```
chmod +x build_rpi_kernel.sh
```

현재 작업 디렉토리를 KERNEL_TOP_PATH에 저장

```
KERNEL_TOP_PATH="$( cd "$(dirname "$0")" ; pwd -P )"
```

KERNEL_TOP_PATH 경로에 out 폴더를 추가해 OUTPUT이라는 셸 스크립트 변수에 저장

OUTPUT 변수는 "/home/pi/rpi_kernel_src/out" 으로 변경

```
OUTPUT="$KERNEL_TOP_PATH/out"
```

여기서 설정한 OUTPUT은 커널 컨피그와 커널 빌드 명령어에서 "0=$OUTPUT" 형식으로 사용

```
make 0=$OUTPUT bcm2709_defconfig
make 0=$OUTPUT zImage modules dtbs -j4 2>&1 | tee $BUILD_LOG
```

커널 컨피그 파일을 생성하는 코드

```
make 0=$OUTPUT bcm2709_defconfig
```

위 명령어는 bcm2709_defconfig 파일에 선언된 컨피그 파일을 참고해 .config 파일을 생성

```
/home/pi/rpi_kernel_src/out/.config
```

 리눅스 커널 소스 빌드 명령어

```
make 0=$OUTPUT zImage modules dtbs -j4 2>&1 | tee $BUILD_LOG
```

커널 빌드 로그 저장 코드

$KERNEL_TOP_PATH 디렉터리 안의 rpi_build_log.txt 라는 파일을 지정해 BUILD_LOG에 저장

```
BUILD_LOG="$KERNEL_TOP_PATH/rpi_build_log.txt"
...
make 0=$OUTPUT zImage modules dtbs -j4 2>&1 | tee $BUILD_LOG
```

>  명령어 tee - read from standard input and write to standard output and files

build_rpi_kernel.sh 스크립트로 커널 빌드

```
ojs@raspberrypi:/home/pi/rpi_kernel_src $ build_rpi_kernel.sh 
configure build output path
/home/pi/rpi_kernel_src/out
move kernel source
make defconfig
#
# configuration written to .config
#
kernel build
scripts/kconfig/conf  --syncconfig Kconfig
  CALL    scripts/checksyscalls.sh
  CHK     include/generated/compile.h
  GZIP    kernel/config_data.gz
  Kernel: arch/arm/boot/Image is ready
  Building modules, stage 2.
  Kernel: arch/arm/boot/zImage is ready
  MODPOST 1607 modules
```

만약 컴파일 에러가 발생한다면 반드시 리눅스 커널 코드를 수정한 다음 다시 커널 빌드를 해야 한다.

### 라즈비안 리눅스 커널 설치

커널 코드를 빌드만 해서는 수정한 코드가 라즈베리 파이에서 실행되지 않는다. 컴파일해 생성된 이미지를 라즈베리 파이에 설치해야 한다. 라즈비안 리눅스 커널을 빌드했으니 이제 빌드한 커널 이미지를 설치해본다. 다음은 라즈비안 이미지를 라즈베리 파이에 설치하는 셸 스크립트이다.

***install_rpi_kernel_img.sh***

```sh
#!/bin/bash

KERNEL_TOP_PATH="$(pwd)"
OUTPUT="$KERNEL_TOP_PATH/out"

echo "$OUTPUT"

cd linux

make 0=$OUTPUT modules_install
cp $OUTPUT/arch/arm/boot/dts/*.dtb /boot/
cp $OUTPUT/arch/arm/boot/dts/overlays/*.dtb* /boot/overlays/
cp $OUTPUT/arch/arm/boot/dts/overlays/README /boot/overlays/
cp $OUTPUT/arch/arm/boot/zImage /boot/kernel7.img
```

install_rpi_kernel_img.sh 스크립트 실행

### 전처리 코드 생성

리눅스 커널을 캡슐화나 다형성과 같은 객체지향으로 구현하다 보니 매크로로 구현된 코드가 많다. 그런데 이 매크로가 소스 분석의 걸림돌 중 하나로 작용한다.

전처리 코드는 이러한 매크로를 모두 풀어서 표현한다. 따라서 훨씬 편하게 소스코드를 분석할 수 있으며, 리눅스 커널 코드를 분석할 때는 전처리 코드를 함께 본다.

전처리 코드는 GCC 컴파일 오브젝트를 생성하는 과정에서 추출된다. 커널에서 전처리 코드를 추출하는 방법은 크게 두 가지가 있다.

* 전체 전처리 파일을 추출
* 특정 전처리 파일을 추출

#### 전체 전처리 파일을 추출하는 방법

전처리 구문

```makefile
-save-temps=obj \
```

***/home/pi/rpi_kernel_src/linux/Makefile***  410L ~

```makefile
# Use LINUXINCLUDE when you must reference the include/ directory.
# Needed to be compatible with the O= option
LINUXINCLUDE    := \
		-I$(srctree)/arch/$(SRCARCH)/include \
		-I$(objtree)/arch/$(SRCARCH)/include/generated \
		$(if $(KBUILD_SRC), -I$(srctree)/include) \
		-I$(objtree)/include \
		$(USERINCLUDE)

KBUILD_AFLAGS   := -D__ASSEMBLY__
KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
		   -fno-strict-aliasing -fno-common -fshort-wchar \
		   -Werror-implicit-function-declaration \
		   -Wno-format-security \
		   -std=gnu89
```

-Wno-format-security \ 와 -std=gnu89 사이에 전처리 구문 삽입

```makefile
# Use LINUXINCLUDE when you must reference the include/ directory.
# Needed to be compatible with the O= option
LINUXINCLUDE    := \
		-I$(srctree)/arch/$(SRCARCH)/include \
		-I$(objtree)/arch/$(SRCARCH)/include/generated \
		$(if $(KBUILD_SRC), -I$(srctree)/include) \
		-I$(objtree)/include \
		$(USERINCLUDE)

KBUILD_AFLAGS   := -D__ASSEMBLY__
KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
		   -fno-strict-aliasing -fno-common -fshort-wchar \
		   -Werror-implicit-function-declaration \
		   -Wno-format-security \
		   -save-temps=obj \
		   -std=gnu89
```

저장 후 build_rpi_kernel.sh 스크립트 실행

그러면 전처리 코드가 out 폴더에 생성된다.

이후 전처리 코드가 어떻게 생성되었는지 확인해본다.

C 언어로 작성된 리눅스 커널 소스 파일은 다음 위치에서 전처리 파일로 생성된다.

```
linux/kernel/sched/core.c
out/kernel/sched/.tmp_core.i
```

### 리눅스 커널 소스의 구조

리눅스 커널 코드의 디렉터리 구조를 살펴본다.

#### arch

arch 하부 디렉터리에는 아키텍처별로 동작하는 커널 코드가 있다.

#### include

include에는 커널 코드 빌드에 필요한 헤더 파일이 있다.

#### Documentation

커널 기술 문서가 있는 폴더로, 커널 시스템에 대한 기본 동작을 설명하는 문서를 찾을 수 있다. 커널 개발자를 대상으로 작성된 문서이다.

#### kernel

커널의 핵심 코드가 있는 디렉터리이다.

#### mm

Memory Management의 약자로 가상 메모리 및 페이징 관련 코드가 들어 있다.

#### drivers

모든 시스템의 디바이스 드라이버 코드가 있다. 하부 디렉터리에 드라이버 종류별 소스가 들어 있다.

#### fs

모든 파일 시스템 코드가 담긴 폴더이다. fs 폴더에 있는 파일에는 파일 시스템 공통 함수가 들어 있고 파일 시스템별로 하나씩 세분화된 폴더를 볼 수 있다.

#### lib

lib 디렉터리에는 커널에서 제공하는 라이브러리 코드가 있다. 아키텍처에 종속적인 라이브러리 코드는 arch/*/lib/에 있다.

## objdump 바이너리 유틸리티

바이너리 유틸리티는 오브젝트 포맷의 파일을 조작할 수 있는 프로그램이다. 

# 커널 디버깅과 코드 학습

커널 디버깅은 실전 개발과 코드 학습에 매우 중요하다. 커널 코드만 분석할 때보다 디버깅 과정을 통해 콜 스택이나 함수 실행 빈도와 같은 정보를 더 얻을 수 있기 때문이다.

## 디버깅이란?

디버깅은 단지 버그를 잡는 과정으로만 보면 안된다. 리눅스 커널과 드라이버가 정상 동작할 때 자료구조와 함수 호출 흐름까지 파악하는 과정을 디버깅이라고 한다.

### 디버깅은 문제 해결 능력의 지름길

신입 개발자들은 실전 리눅스 개발에서 어떤 업무를 하는지 궁금해한다. 임베디드 리눅스는 '클라우드 서버', '휴대폰', '전기자동차' 분야까지 다양한 분야에서 쓰이고 있다. 따라서 실전 개발 업무가 어떻다고 설명하긴 어렵다. 하지만 어떤 업무를 맡고 있더라도 공통적으로 리눅스 커널 디버깅에 관심을 가져야 한다.

#### 커널 디버깅을 잘해야 문제 해결 능력을 키울 수 있는 이유는?

대부분의 임베디드 및 BSP 개발자들은 커널 디버깅 능력을 키우기 위해 노력한다. 커널 디버깅 능력을 업그레이드하려는 이유는 무엇일까? 이유는 간단한데, 커널 디버깅은 문제 해결 능력 그 자체이기 때문이다.

#### 커널 디버깅 따라해보기 : 커널 로그 분석

임베디드 리눅스 개발을 하다가 문제가 생기면 대부분 커널 로그를 본다. 그런데 디바이스 드라이버 코드에 오류가 있으면 우리가 작성한 드라이버 코드에서 오류 메시지를 출력하지 않는다. 대부분의 경우 디바이스 드라이버가 호출한 커널 함수 내부에서 에러 메시지를 출력한다.

### 디버깅과 코드 학습 능력

디버깅을 하면서 리눅스 커널 코드를 함께 분석하면 다음과 같은 정보를 더 얻을 수 있다.

* 분석 대상 코드가 동작하는 콜 스택
* 함수가 실행될 때 변경되는 자료구조
* 함수가 실행되는 빈도와 실행 시각
* 분석 대상 코드를 실행하는 프로세스

## printk() 함수

C 프로그래밍을 공부할 때 가장 먼저 만나는 함수가 main과 printf이다.

```c
printf("hello world \n");
```

윈도우 콘솔 프로그램이나 리눅스 시스템 프로그램에서 printf 함수를 호출하면 콘솔로 문자열을 출력하듯이 printk() 함수를 호출하면 커널 로그를 볼 수 있다. 이미 커널의 수많은 내부 함수에서도 printk를 이용해 에러 정보를 커널 로그로 출력한다.

### printk를 사용하는 예제 코드 확인

커널의 핵심 코드에서 printk를 쓰는 사례

### printk 자료형에 따른 서식 지정

printk에 전달하는 서식 지정자를 살펴본다. 예를 들어, 정수형 포맷으로는 int, long, long long을 지원한다. C 언어의 printf와 같다.

### printk로 함수 심벌 정보를 보는 방법

printk로 포인터를 출력하고 싶을 때는 %p를 쓰면 된다. 커널은 심벌 테이블을 갖고 있으므로 %pS를 쓰면 함수 주소를 심벌로 출력한다. 이는 함수 포인터를 디버깅할 때 자주 쓰는 기법이다.

라즈비안 리눅스 커널 코드에 직접 printk 코드를 입력하는 실습을 한다. 다음 코드를 리눅스 커널 코드에 입력한다.

### printk를 쓸 때 주의해야 할 점

printk를 사용할 때는 printk의 호출 빈도를 반드시 체크해야 한다. 만약 리눅스 커널에서 1초에 수백번 이상 호출되는 함수에 printk를 사용하면 시스템이 락업(Lockup)되거나 커널 패닉으로 오동작할 수 있다. 여기서 락업은 라즈베리파이와 같은 리눅스 디바이스에서 마우스를 움직이거나 키보드를 입력해도 아무런 반응이 없는 상황을 말한다.

그 이유는 printk가 커널 입장에서 많은 비용이 드는 함수이기 때문이다. printk는 파일 시스템의 도움으로 로그를 콘솔 버퍼에 저장하는 세부 동작을 수행한다. 이때 커널 세부 동작을 콘솔 드라이버에서 처리하고 커널 로그를 저장하는 동작을 백그라운드로 처리한다. 

## dump_stack() 함수

printk 외에도 커널에서는 커널 로그를 통해 커널 동작을 보여주는 기능을 제공한다. 즉, 커널에서 지원하는 dump_stack() 함수를 호출하면 콜 스택을 커널 로그로 볼 수 있다.

dump_stack() 함수의 사용법은 간단하다. 커널 로그로 콜 스택을 보고 싶은 코드에 dump_stack() 함수를 추가하면 된다.

### dump_stack() 함수로 커널 로그에서 콜 스택 확인하기

앞서 본 dump_stack() 함수를 써서 커널 로그로 콜 스택을 볼 수 있는 방법을 알아본다.

### dump_stack() 함수를 사용할 때의 주의사항

1초에 100번 이상 호출되는 함수에 dump_stack() 함수를 추가하면 시스템 응답 속도가 매우 느려질 수 있다. 따라서 dump_stack() 함수를 호출해서 콜 스택을 보려는 코드가 자주 호출되는지 반드시 점검할 필요가 있다.

## ftrace

리눅스 커널에서 제공하는 강력한 디버그 기능인 ftrace를 소개한다. ftrace 기능을 활용해 콜 스택과 커널의 세부 동작을 분석한다.

실무에서도 ftrace를 자주 활용해 커널 디버깅을 한다. 따라서 ftrace의 사용법을 잘 익히고 ftrace 메시지를 자주 분석한다.

### ftrace란?

printk와 dump_stack을 활용해 커널 디버깅을 하던 리눅스 커널 개발자들은 여러 불편함을 느꼈다. 즉, 다음과 같은 요건을 충족하는 커널 디버깅 기능이 있으면 좋겠다고 생각하게 된다.

* 함수 호출 흐름을 소스코드를 수정하지 않고도 보고 싶다.
* 커널의 세부 실행 정보를 출력해 줬으면 좋겠다.
* 1초에 수십 번 호출해도 성능에 부담을 주지 않았으면 좋겠다.
* 커널 로그도 함께 보고 싶다.

### ftrace는 어떻게 설정할까?

ftrace에서 제공하는 nop, function, function_graph 트레이서를 쓰려면 ftrace 관련 코드가 커널 이미지에 포함돼야 한다. 즉, ftrace 코드가 추가된 커널 소스를 빌드해야 한다.

이를 위해 커널 설정 configuration를 활성화해야 한다.

#### ftrace 설정

먼저 ftrace를 설정하는 방법을 설명한다. 

**tracing_on : 트레이서 활성화/비활성화하기**

ftrace를 활성화/비활성화하려면 tracing_on 파일을 설정해야 한다. tracing_on은 부팅 후 기본적으로 0으로 설정돼 있다.

**tracer 설정**

ftrace는 nop, function, function_graph 같은 트레이서를 제공한다. ftrace에서 다양한 트레이서를 제공하는데, 중요한 부분만 추려 소개하면 다음과 같다.

**ftrace 이벤트 설정**

ftrace에서는 커널을 구성하는 서브시스템과 기능별로 세부 동작을 출력하는 기능을 지원한다. 이를 이벤트라고 한다.

**필터 설정 : set_ftrace_filter**

set_ftrace_filter 파일에 트레이싱하고 싶은 함수를 지정한다. set_ftrace_filter는 현재 트레이서를 function_graph와 function으로 설정할 경우 작동하는 파일이다. 이 파일에 디버깅하고 싶은 함수의 이름을 지정하면 된다. 이를 가리켜 함수 필터를 지정한다고 표현한다. 그런데 여기서 주의할 점이 있다.

**추가 설정 파일**

다음으로 추가 설정 파일을 간략하게 소개한다.

### ftrace 메시지는 어떻게 분석할까?

ftrace를 제대로 활용하려면 먼저 ftrace 메시지를 읽고 해석하는 방법을 알아야 한다. 다시 강조하지만 ftrace는 커널 동작을 세부 로그로 출력하기 때문에 임베디드 리눅스 개발자에게 축복과도 같다.

#### ftrace 이벤트 분석하기

이어서 ftrace 중에서 가장 많이 쓰는 아래의 두 가지 이벤트를 분석하는 방법을 소개한다.

* sched_switch
* irq_handler_entry/irq_handler_exit

### ftrace 로그는 어떻게 추출할까?

ftrace 로그를 라즈베리파이에서 추출하는 방법을 소개한다.

### ftrace는 커널 코드 분석의 안내자

ftrace 메시지는 텍스트 포맷이라서 많은 사람들이 해석하기 어렵다고 불평한다. 하지만 ftrace 메시지는 바로 커널 코드 분석의 안내자일 수 있다. 바로 ftrace 이벤트의 이름으로 커널 내부의 어떤 소스에서 이벤트를 출력하는지 알 수 있기 때문이다.

## 임베디드 디버거의 전설 TRACE32

TRACE32(T32)는 임베디드 소프트웨어에서 많이 사용되는 전설적인 디버깅 프로그램이다. 다른 RTOS 개발에도 활용도가 높은 디버깅 프로그램으로서 대부분의 임베디드 개발자는 TRACE32를 사용할 줄 알고, 많은 고수 개발자들은 TRACE32를 잘 다룬다. 실전 개발에서 활용도가 높으니 잘 알아둘 필요가 있다.

#### 섹션 정보 보기

먼저 TRACE32 명령어 창에 "symbol.list.section" 명령어를 입력하면 섹션 정보를 볼 수 있다.

#### 주소로 코드 정보 파악

"symbol.list.line [주소]" 명령어로 주소를 입력하면 주소에 해당하는 코드의 위치를 알 수 있다. 예를 들어, "symbol.list.line 0x80783a78"을 입력하면 다음과 같은 결과를 확인할 수 있다.

#### 전역 변수 확인

"var.view [전역 변수 이름]" 명령어를 입력하면 전역 변수를 볼 수 있다. 다음은 "var.view %l %t init_thread_union" 명령어를 실행한 결과이다.

#### 구조체를 주소로 캐스팅

다음과 같은 형식의 명령어를 실행하면 어떤 주소든 지정한 구조체로 캐스팅할 수 있다.

#### 어셈블리 코드 보기

"data.list 주소" 형식으로 명령어를 입력하면 주소에 해당하는 어셈블리 코드를 볼 수 있다. 다음은 "data.list 0x80783a78"을 입력했을 때의 결과 화면이다.

## 커널 디버깅용 Debugfs 드라이버 코드

지금까지 커널 디버깅 방법, 즉 리눅스 커널 코드를 수정해서 ftrace나 커널 로그를 받아 분석하는 과정을 다뤘다. 커널에 익숙하지 않은 사람들은 커널 코드를 수정하는 것이 낯설을 것이다.

실수로 커널 코드를 잘못 입력하면 시스템이 오동작할 수 있다. 아예 라즈베리파이가 부팅을 못할 수도 있다. 

임베디드 리눅스 개발자는 코드를 수정한 다음 커널 부팅이 안 되는 상황을 종종 겪는다. 하지만 실전 개발에서는 각자 개발 환경에서 제공하는 응급 다운로드 프로그램을 사용해 백업한 커널 이미지를 내려받을 수 있다. 하지만 라즈베리파이로 리눅스를 처음 접하는 사람의 상황은 다르다. 커널 코드를 수정한 라즈베리파이가 부팅하지 못하면 적잖이 당황하게 된다. 물론 라즈베리파이를 다시 설치하면 되지만 시간이 더 오래 걸릴 수 있다.

그래서 수정한 커널 코드가 특정 조건에서만 동작하도록 도와주는 간단한 debugfs 드라이버 코드를 사용한다. 이를 활용하면 훨씬 편한 마음으로 커널 로그를 수정 후 빌드할 수 있다.

#### rpi_debugfs 소스코드

#### rpi_debugfs 동작 확인

#### rpi_debugfs로 전역 변수 바꿔보기

#### rpi_debugfs를 활용한 커널 코드 변경

# 프로세스

프로세스(process)를 제대로 이해하는 것은 어렵다. 여러 이유가 있겠지만 프로세스를 이론으로만 이해하는 방식으로 공부하기 때문이다. 프로세스는 그러한 방식으로 학습하기가 어렵다. 프로세스와 관련된 자료구조나 ftrace 로그 분석을 통해 프로세스를 익혀야 한다.

## 프로세스 소개

### 프로세스란?

프로세스라는 용어는 추상적이고 다양한 의미를 담고 있어 프로세스가 무엇인지 다양한 관점으로 바라볼 수 있다.

프로세스란 간단히 말해서 리눅스 시스템 메모리에서 실행 중인 프로그램을 말한다. 스케줄링 대상인 태스크와 유사한 의미로도 쓰인다. 다수의 프로세스를 실시간으로 사용하는 기법을 멀티프로세싱이라고 하며, 같은 시간에 여러 프로그램을 실행하는 방식을 멀티태스킹이라고 한다.

### 태스크란?

리눅스 커널 함수의 이름에 'task'가 보인다. 사실 태스크는 리눅스 외의 다른 운영체제에서 예전부터 많이 쓰던 용어이다. 운영체제 이론을 다루는 책에서는 태스크라는 단어를 많이 볼 수 있다.

태스크는 운영체제에서 어떤 의미인가? 말 그대로 실행(Execution)이라 말할 수 있다.

운영체제 책을 보면 첫 장에서 태스크에 대한 설명을 볼 수 있다. 예전에는 특정 코드나 프로그램 실행을 일괄 처리했다. 이러한 실행 및 작업 단위를 태스크라고 불렀다.

### 스레드란?

스레드(thread)란 무엇인가? 스레드는 유저 레벨에서 생성된 가벼운 프로세스라 할 수 있다. 스레드는 일반 프로세스에 비해 컨텍스트 스위칭을 수행할 때 시간이 적게 걸린다. 그 이유는 스레드는 자신이 속한 프로세스 내의 다른 스레드와 파일 디스크립터, 파일 및 시그널 정보에 대한 주소 공간을 공유하기 때문이다. 프로세스가 자신만의 주소 공간을 갖는 것과 달리 스레드는 스레드 그룹 안의 다른 스레드와 주소 공간을 공유한다.

하지만 커널 입장에서는 스레드를 다른 프로세스와 동등하게 관리한다. 대신 각 프로세스 식별자인 태스크 디스크립터(task_struct)에서 스레드 그룹 여부를 점검할 뿐이다.

## 프로세스 확인하기

프로세스에 익숙해지려면 먼저 리눅스 시스템에서 프로세스를 출력하는 명령어를 자주 입력하고 ftrace 로그에서 프로세스 관련 정보를 자주 봐야 한다. 그래서 이번 장에서는 라즈베리 파이에서 터미널을 열어서 명령어를 입력하고 ftrace 로그로 프로세스 동작을 확인한다. 

### ps 명령어로 프로세스 목록 확인

먼저 라즈베리 파이에서 터미널을 실행한 후 다음과 같이 "ps -ely" 명령어를 입력한다.

### ftrace에서 프로세스 확인하기

ftrace를 열어보면 다양한 이벤트 메시지를 볼 수 있다. 공통적으로 모든 ftrace 메시지의 맨 왼쪽 부분에서 프로세스 정보를 볼 수 있다.

## 프로세스는 어떻게 생성할까?

프로세스 생성 과정을 왜 알아야 하는걸까? 리눅스 커널에서 프로세스를 생성하는 함수를 분석하면 자연히 다음과 같은 내용을 알게 된다.

* 프로세스가 부모 프로세스로부터 어떻게 복제되는가?
* 생성된 프로세스가 어떻게 실행을 시작하는가?
* 프로세스 자료구조는 어떻게 처리하는가?

### _do_fork() 함수 소개

리눅스에서 구동 중인 모든 프로세스는 _do_fork() 함수가 실행할 때 생성된다. 프로세스는 누가 생성할까? 리눅스에서 프로세스 생성을 전담하는 프로세스가 있다. 주인공은 init과 kthread 프로세스이다. 특히 init 프로세스는 부팅 과정에서 유저 프로세스를 생성하는 역할을 담당한다.

#### _do_fork() 함수 선언부와 반환값 확인

먼저 _do_fork() 함수의 선언부를 보면서 이 함수에 전다로디는 인자와 반환값을 확인해 본다.

#### 커널에서 _do_fork() 함수를 언제 호출할까?

커널에서 프로세스를 생성할 때 프로세스 유형에 따라 _do_fork() 함수를 호출하는 흐름은 다르다.

1. 유저 모드에서 생성한 프로세스 : sys_clone() 시스템 골 핸들러 함수
2. 커널 모드에서 생성한 커널 스레드 : kernel_thread() 함수

프로세스는 유저 모드에서 생성된 프로세스와 커널 모드에서 생성된 프로세스로 분류할 수 있다. 이를 각각 유저 레벨 프로세스와 커널 레벨 프로세스라고 한다.

다음 절에서는 유저 레벨 프로세스를 생성할 때 어떤 흐름으로 _do_fork() 커널 함수를 호출하는지 살펴본다.

### 유저 레벨 프로세스를 생성할 때 _do_fork() 함수의 처리 흐름

#### sys_clone() 함수 분석

### 커널 프로세스 생성 시 _do_fork() 함수의 흐름

커널 프로세스를 생성할 때도 _do_fork() 함수를 호출한다. 그럼 커널 프로세스란 무엇인가? 커널 프로세스란 시스템 콜 없이 커널 함수로 생성되어 커널 공간에서만 실행되는 프로세스를 의미한다. 커널 프로세스의 대표적인 예로 커널 스레드를 들 수 있다. 커널 스레드는 커널 공간에서 시스템 리소스(메모리, 전원) 관리를 수행한다.

## 유저 레벨 프로세스 실행 실습

### 기본 유저 레벨 프로세스 실행 실습 및 ftrace 로그 분석

#### ps 명령어를 이용한 프로세스 목록 확인

터미널에 "ps -ely | grep bash" 명령어를 입력한다.

#### 유저 프로세스 실습 코드 소개

리눅스 시스템 프로그래밍으로 프로세스를 생성한다. 소스코드는 다음과 같다.

#### ftrace 설정 방법 따라해보기

이번에는 ftrace 로그를 설정하는 방법을 소개한다. raspbian_proc 프로세스가 어떻게 생성되고 실행되는지 파악하려면 다음과 같은 명령어로 ftrace를 설정할 필요가 있다.

#### raspbian_proc 프로세스와 ftrace를 실행해 프로세스 실행과 종료 로그 확보하기

앞에서와 같이 코드를 작성한 후 clone_process_debug.sh라는 이름으로 저장한 후 다음과 같이 이 셸 스크립트를 실행한다.

#### ftrace 메시지로 프로세스 생성과 종료 과정 분석하기

raspbian_proc 프로세스를 실행하고 강제로 종료된 동작이 포함된 ftrace 로그를 확보했다. 이제 커널 공간에서 raspbian_proc 프로세스가 어떤 코드 흐름으로 생성되고 종료되는지 살펴본다. 분석할 전체 ftrace 로그는 다음과 같다.

#### 1단계 : 프로세스 생성 단계의 ftrace 메시지 분석

먼저 유저 공간에서 _do_fork() 함수가 호출되면 다음과 같은 흐름으로 프로세스를 생성한다.

#### 2단계 : raspbian_proc 프로세스 실행에 대한 ftrace 메시지 분석

raspbian_proc(pid:1360) 프로세스가 실행되는 동작을 나타낸다.

#### 3단계 : 프로세스 종료에 대한 ftrace 메시지 분석

raspbian_proc 프로세스가 종료되는 3단계 로그를 분석한다.

#### 4단계 : 부모 프로세스에게 시그널을 전달하는 과정에 대한 ftrace 메시지 분석

프로세스는 종료할 때 부모 프로세스에게 SIGHLD 시그널을 전달한다. 이 규칙에 따라 종료되는 raspbian_proc 프로세스는 부모 프로세스인 bash(pid:946)에게 시그널을 전달한다. 

### exit() 함수로 프로세스가 종료되는 과정 및 ftrace 로그 분석

유저 프로세스는 '종료' 시그널을 받아 소멸될 수 있지만 프로세스가 POSIX exit 시스템 콜을 호출해서 스스로 종료할 수도 있다.

유저 프로세스가 POSIX exit 시스템 콜을 발생시켰을 때 커널 내부에서 어떤 흐름으로 프로세스가 종료되는지 살펴본다.

#### 실습 코드를 작성하고 컴파일하기

#### rpi_proc_exit 프로세스 실행과 ftrace 로그 추출

#### ftrace 메시지를 활용한 프로세스 생성과 종료 과정 분석

## 커널 스레드

### 커널 스레드란?

커널 프로세스는 커널 공간에서만 실행되는 프로세스이다. 대부분 커널 스레드 형태로 동작한다. 커널 스레드는 리눅스 시스템 프로그래밍에서 데몬과 비슷한 일을 하는데, 데몬과 커널 스레드는 백그라운드 작업으로 실행되면서 시스템 메모리나 전원을 제어하는 동작을 수행한다. 그런데 커널 스레드는 유저 영역과 시스템 콜을 받지 않고 동작한다. 이 점이 데몬과 커널 스레드의 차이점이다.

커널 스레드는 다음과 같은 세 가지 특징이 있다.

* 커널 스레드는 커널 공간에서만 실행되며, 유저 공간과 상호작용하지 않는다.
* 커널 스레드는 실행, 휴면 등 모든 동작을 커널에서 직접 제어 관리한다.
* 대부분의 커널 스레드는 시스템이 부팅할 때 생성되고 시스템이 종료할 때까지 백그라운드로 실행된다.

### 커널 스레드의 종류

리눅스는 다양한 배포판에서 구동된다. 그런데 어떤 리눅스 시스템에서도 볼 수 있는 커널 스레드가 있다.

#### 라즈베리파이에서 커널 스레드 항목 확인

먼저 커널에서 구동 중인 대표적인 커널 스레드를 확인해 본다. 라즈베리파이에서 터미널을 열고 'ps axjf' 명령어를 입력한다.

### 커널 스레드는 어떻게 생성할까?

이어서 커널 스레드를 생성하는 과정에서 호출되는 함수를 소개하고 세부 코드를 분석한다. 커널 스레드가 생성되는 과정은 크게 2단계로 나눌 수 있다.

* 1단계 : kthreadd 프로세스에게 커널 스레드 생성을 요청

  * kthread_create()

  * kthread_create_on_node()

* 2단계 : kthreadd 프로세스가 커널 스레드를 생성

  * kthreadd()

  * create_kthread()

#### 1단계 : kthreadd 프로세스에게 커널 스레드 생성 요청

유저 프로세스를 생성하려면 유저 애플리케이션에서 fork() 함수를 호출해야 하듯이, 커널 스레드를 생성하려면 kthread_create() 커널 함수를 호출해야 한다. 먼저 kthreadd 프로세스에게 커널 스레드 생성 요청을 하는 함수 실행 흐름을 살펴본다.

**kthread_create() 함수 분석**

커널 스레드를 생성하려면 먼저 kthread_create() 함수를 호출해야 한다. 다음 코드는 kthread_create() 함수로서, 매크로 형태로 작성된 것을 알 수 있다.

**kthread_create_on_node() 함수 분석**

kthread_create() 매크로 함수의 실체인 kthread_create_on_node() 함수의 구현부를 본다.

#### 2단계 : kthreadd 프로세스가 커널 스레드를 생성

kthreadd 프로세스를 깨우면 kthreadd 프로세스의 스레드 핸들러 kthreadd() 함수가 실행을 시작한다.

**kthreadd() 함수 분석**

kthreadd 프로세스의 스레드 핸들러인 kthreadd() 함수를 분석한다.

**create_kthread() 함수 분석**

**kernel_thread() 함수 분석**

## 커널 내부 프로세스의 생성 과정

### _do_fork() 함수

_do_fork() 함수의 동작은 크게 2단계로 분류할 수 있다.

* 1단계 : 프로세스 생성

  copy_process() 함수를 호출해서 프로세스를 생성한다. copy_process() 함수는 이름에서 볼 수 있듯이 부모 프로세스의 리소스를 자식 프로세스에게 복제한다.

* 2단계 : 생성한 프로세스의 실행 요청

  copy_process() 함수를 호출해 프로세스를 만든 후 wake_up_new_task() 함수를 호출해서 프로세스를 깨운다. 프로세스를 깨운다는 의미는 스케줄러에게 프로세스 실행 요청을 하는 것이다.

_do_fork() 함수의 전체 흐름을 알아봤으니 _do_fork() 함수의 소스코드를 분석해 본다.

### copy_process() 함수 분석

프로세스를 생성하는 핵심 동작은 copy_process() 함수에서 수행한다. 대부분 부모 프로세스에 있는 리소스를 복사하는 동작이다. 그럼 copy_process() 함수 코드를 본격적으로 분석해 본다. 

### wake_up_new_task() 함수 분석

프로세스 생성의 마지막 단계로 생성한 프로세스를 깨운다. 이 동작은 wake_up_new_task() 함수가 수행한다.

* 프로세스 상태를 TASK_RUNNING으로 변경
* 현재 실행 중인 CPU 번호를 thread_info 구조체의 cpu 필드에 저장
* 런큐에 프로세스를 큐잉

## 프로세스의 종료 과정 분석

프로세스는 크게 두 가지 흐름으로 종료된다.

* 유저 애플리케이션에서 exit() 함수를 호출할 때
* 종료 시그널을 전달받을 때

### 프로세스 종료 흐름 파악

커널에서 제공하는 do_exit() 함수를 실행하면 프로세스를 종료할 수 있다. do_exit() 함수에서 커널이 프로세스를 종료하는 코드를 분석하기에 앞서 do_exit() 함수가 어떤 흐름으로 호출되는지 살펴본다.

#### exit() 시스템 콜 실행

위의 그림의 왼쪽은 유저 공간에서 exit 시스템 콜을 발생시켰을 때 프로세스가 종료되는 흐름이다. 보통 유저 프로세스가 정해진 시나리오에 따라 종료해야 할 때 exit() 함수를 호출한다. 시스템 콜이 발생한 후 해당 시스템 콜 핸들러인 sys_group_exit() 함수가 호출된다. 이후 do_exit() 함수를 호출한다. 

#### 종료 시그널을 전달받았을 때

오른쪽은 kill 시그널을 받아 프로세스가 소멸하는 흐름이다. 유저 프로세스뿐만 아니라 커널 프로세스도 커널 내부에서 종료 시그널을 받으면 소멸된다. 참고로 커널 함수로 send_signal() 함수를 호출하면 특정 프로세스에게 종료 시그널을 전달할 수 있다. 종료 시그널을 받은 프로세스는 do_exit() 함수를 실행해 소멸된다.

### do_exit() 함수 분석

do_exit() 함수의 이름만 보더라도 '종료를 실행한다'라는 동작을 할 것이라 예상할 수 있다. 여기서 '종료를 실행한다'의 주체는 프로세스이다. 이번 절에서는 do_exit() 함수를 분석하면서 프로세스가 종료되는 과정을 살펴본다.

#### do_exit() 함수 선언부와 인자 확인

먼저 do_exit() 함수에 전달되는 인자와 반환값을 확인한다.

#### do_exit() 함수의 동작 방식 확인

do_exit() 함수의 실행 단계는 다음과 같이 정리할 수 있다.

#### do_exit() 함수 코드 분석

### do_task_dead() 함수 분석

### do_task_dead() 함수를 호출하고 난 후의 동작

do_task_dead() 함수에서 `__schedule()` 함수를 호출하고 나면 커널은 어떻게 프로세스를 소멸시킬까? 먼저 `__schedule()` 함수를 호출하면 어떤 흐름으로 finish_task_switch() 함수를 호출하는지 살펴본다. 다음은 이번 절에서 분석할 함수의 목록이다.

## 태스크 디스크립터(task_struct 구조체)

프로세스의 속성 정보를 표현하는 가장 중요한 자료구조는 태스크 디스크립터를 나타내는 task_struct 구조체이다. 리눅스 커널에서 가장 중요한 자료구조이다.

### 프로세스를 식별하는 필드

### 프로세스 상태 저장

### 프로세스 간의 관계

### 프로세스 연결 리스트

### 프로세스 실행 시각 정보

## 스레드 정보 : thread_info 구조체

커널에서는 태스크 디스크립터뿐만 아니라 thread_info 구조체로 프로세스 실행 동작을 관리한다.

이번 절에서는 thread_info 구조체를 소개하고 각 필드의 의미를 살펴본다. 또한 thread_info 구조체 중 preempt_count 필드를 중심으로 프로세스의 실행 흐름을 분석한다.

### thread_info 구조체란?

태스크 디스크립터는 프로세스의 공통 속성 정보를 저장하고 관리한다. 추가로 커널에서는 프로세스의 세부 실행 정보를 저장하거나 로딩하는 자료구조가 필요한데 이를 thread_info 구조체에서 관리한다.

### thread_info 구조체 분석

thread_info 구조체는 프로세스의 실행 흐름을 관리하는 중요한 정보를 저장한다. 프로세스 스케줄링을 실행할 때 이전에 실행했던 레지스터 세트 정보와 프로세스의 컨텍스트 정보를 이 구조체 필드에서 확인할 수 있다.

#### thread_info 구조체 선언부 분석

#### thread_info 구조체 필드 확인

### thread_info 구조체의 주소 위치는 어디인가?

#### 프로세스 스택에서 thread_info 구조체의 위치 확인

thread_info 구조체는 프로세스의 세부 실행 속성 정보를 담고 있으며 프로세스마다 1개씩 존재한다.

#### 프로세스가 스택을 어떻게 쓰는지 알아보기

리눅스 커널에서 프로세스 스택은 높은 주소에서 낮은 주소 방향으로 자란다. 함수는 프로세스 스택의 최하단 주소(0x80C02000)에서 최상단 주소(0x80C00000) 방향으로 호출된다.

### 컨텍스트 정보 상세 분석

thread_info 구조체의 필드 중 preempt_count는 프로세스의 컨텍스트 정보를 저장한다.

#### 인터럽트 컨텍스트 실행 상태 저장

리눅스 시스템에서 인터럽트는 언제든지 발생할 수 있다. 인터럽트가 발생하면 프로세스 실행을 멈추고 인터럽트에 해당하는 인터럽트 핸들러를 실행한다. 커널에서는 인터럽트가 발생해서 인터럽트 서비스 루틴을 실행하는 동작을 인터럽트 컨텍스트라고 부른다.

#### 인터럽트 컨텍스트의 종료 상태 저장

인터럽트 서비스 루틴을 종료한 다음에 호출하는 irq_exit() 함수를 본다.

#### Soft IRQ 컨텍스트의 시작 상태 저장

프로세스가 Soft IRQ 서비스를 처리 중이면 preempt_count 필드에 SOFTIRQ_OFFSET 매크로를 저장한다. 

#### Soft IRQ 컨텍스트의 종료 상태를 저장

#### thread_info 구조체의 preempt_count 필드를 이용한 선점 스케줄링 여부 확인

리눅스 커널의 핵심 동작은 스케줄링이다. 프로세스는 shedule() 함수를 호출해서 명시적으로 스케줄링할 수도 있지만 인터럽트가 처리된 후 선점 스케줄링될 수 있다. 커널은 스케줄링 동작 중에 thread_info 구조체의 preempt_count 필드에 저장된 값을 보고 선점 스케줄링 실행 여부를 판단한다.

### cpu 필드에 대한 상세 분석

thread_info 구조체의 cpu 필드는 프로세스가 실행 중인 CPU 번호를 저장한다. 그러면 현재 코드가 어떤 CPU에서 구동 중인지 알려면 어떤 함수를 써야 하는가? 커널에서 제공하는 smp_processor_id() 함수를 호출하면 된다.

#### smp_processor_id() 함수 분석

#### smp_processor_id() 함수의 전체 흐름 파악

커널의 다양한 코드에서 smp_processor_id() 함수를 호출해 현재 실행 중인 CPU 번호를 읽는다. 이번에는 resched_curr() 함수에서 smp_processor_id() 함수를 호출했을 때의 실행 흐름을 확인한다.

#### set_task_cpu() 함수 분석

실행 중인 CPU 번호를 저장하는 thread_info 구조체의 cpu 필드는 set_task_cpu() 함수가 호출될 때 변경된다. set_task_cpu() 함수를 보면서 세부 동작 방식을 분석한다.

### thread_info 구조체 초기화 코드 분석

#### dup_task_struct() 함수 분석

#### alloc_task_struct_node() 함수 분석

#### alloc_thread_stack_node() 함수 분석

## 프로세스의 태스크 디스크립터에 접근하는 매크로 함수

### current 매크로란?

지금까지 살펴봤듯이 프로세스 속성 정보를 관리하는 struct task_struct 타입의 태스크 디스크립터는 커널에서 가장 중요하게 관리하는 자료구조이다. 여기에는 그럴 만한 이유가 있는데, 커널은 태스크 디스크립터에 접근해 프로세스 정보를 수시로 접근하고 저장하며, 태스크 디스크립터에 들어 있는 속성 정보로 함수의 실행 흐름이 바뀌기 때문이다.

#### current 매크로 함수의 사용 예

#### current 매크로 함수의 구현부 분석

current 매크로는 현재 구동 중인 프로세스의 태스크 디스크립터의 주소를 알려주는 역할을 한다. 여기서 구조체는 struct task_struct이고 포인터 타입이다. 그래서 current->comm, current->files 형태로 각 필드에 접근할 수 있다.

### current_thread_info() 매크로 함수 분석

current_thread_info() 매크로 함수는 프로세스가 실행 중일 때 thread_info 구조체가 있는 스택의 최상단 주소를 계산해 반환한다.

#### current_thread_info() 매크로 함수의 사용 예

#### current_thread_info() 매크로 함수의 구현부 분석

## 프로세스 디버깅

### glibc의 fork() 함수를 gdb로 디버깅하기

유저 공간에서 fork() 함수를 호출하면 시스템 콜을 발생시켜 커널 공간에서 fork 시스템 콜 핸들러인 sys_clone() 함수를 호출한다. 이번에는 gdb를 사용해 유저 모드에서 fork() 함수를 호출하면 어떤 코드에서 시스템 콜을 호출하는지 알아본다.

#### 유저 프로세스 실습 코드 소개

#### gdb로 프로세스 생성 과정 디버깅하기

#### __libc_fork() 라이브러리 함수 분석

fork() 함수를 호출했을 때 시스템 콜을 실행하기 직전 어떤 인자로 시스템 콜을 호출하는가?

### 리눅스 유틸리티 프로그램을 이용한 실행 추적

#### ftrace 로그 설정

#### ftrace 로그 분석

#### ftrace 로그 분석 : whoami 명령어를 입력했을 때

#### ftrace 로그 분석 : cat 명령어를 입력했을 때

# 인터럽트

디바이스 드라이버는 주로 외부 하드웨어 장치(키보드, 마우스)와 인터럽트를 통해 통신하는 경우가 많다. 이때 임베디드 리눅스 드라이버 개발자는 인터럽트 핸들러를 등록하고 난 후 관련 인터럽트가 트리거(발생)되면 

## 인터럽트 소개

### 인터럽트란?

인터럽트란 일반적인 상황에서 갑자기 발생하는 비동기적인 통지나 이벤트라고 볼 수 있다.

#### 일상 생활에서의 인터럽트

일상생활에서 인터럽트란 갑자기 생긴 일이나 하던 일을 멈춘다는 의미이다. 일상적으로 하던 일을 멈추게 하는 무엇인가가 갑자기 발생한 상황을 뜻한다. 예를 들면, 책을 읽다가 갑자기 전화가 와서 읽던 책을 덮어 놓고 전화를 받는 상황이 그러하다.

#### 하드웨어 관점에서 인터럽트란?

임베디드 시스템 관점에서 인터럽트란 무엇일까? 먼저 하드웨어 관점에서 생각해 본다. 하드웨어 관점에서 인터럽트란 하드웨어의 변화를 감지해서 외부 입력으로 전달되는 전기 신호이다.

#### CPU 입장에서 인터럽트란?

소프트웨어 관점에서 인터럽트란 무엇인가? 인터럽트가 발생하면 프로세스는 하던 일을 멈추고 '이미 정해진 코드'를 실행해서 하드웨어의 변화를 처리한다. 여기서 '이미 정해진 코드'란, 인터럽트 벡터와 인터럽트 핸들러를 말한다. 이처럼 인터럽트가 발생하면 소프트웨어적으로 처리하는 과정을 인터럽트 서비스 루틴(Interrupt Service Routine)이라고 한다.

### 리눅스 커널 인터럽트의 주요 개념

#### 인터럽트 핸들러란?

인터럽트가 발생하면 이를 핸들링하기 위한 함수가 호출되는데 이를 인터럽트 핸들러라고 한다. 예를 들어, 키보드를 타이핑해서 인터럽트가 발생하면 키보드 인터럽트를 처리하는 키보드 인터럽트 핸들러가 호출된다. 마찬가지로 휴대폰에서 화면을 손으로 만지면 터치 인터럽트가 발생하고 터치 인터럽트를 처리하는 터치 인터럽트 핸들러가 호출된다.

#### 인터럽트 컨텍스트는 언제 활성화될까?

인터럽트 컨텍스트는 현재 실행 중인 코드가 인터럽트를 처리 중이라는 의미이다. 인터럽트 컨텍스트에 대한 이해를 돕기 위해 먼저 소프트웨어 관점에서 인터럽트의 실행 흐름을 단계별로 살펴본다.

1. 프로세스 실행 중
2. 인터럽트 벡터 실행
3. 커널 인터럽트 내부 함수 호출
4. 인터럽트 종류별로 인터럽트 핸들러 호출
   1. 인터럽트 컨텍스트 시작
5. 인터럽트 핸들러의 서브루틴 실행 시작
6. 인터럽트 핸들러의 서브루틴 실행 마무리
   1. 인터럽트 컨텍스트 마무리

#### 인터럽트 디스크립터란?

인터럽트 종류별로 다음과 같은 인터럽트의 세부 속성을 관리하는 자료구조를 인터럽트 디스크립터라고 한다.

* 인터럽트 핸들러
* 인터럽트 핸들러 매개변수
* 논리적인 인터럽트 번호
* 인터럽트 실행 횟수

### 인터럽트를 잘 알아야 하는 이유

커널이 인터럽트를 처리하는 과정과 인터럽트를 관리하는 자료구조를 왜 잘 알아야 할까? 인터럽트를 처리하는 방식이 시스템 전반에 큰 영향을 끼치기 때문이다. 또한 리눅스 커널을 구성하는 요소들을 잘 이해하기 위해서도 커널이 인터럽트를 어떻게 처리하는지 잘 알고 있어야 한다. 또 다른 이유는 다음과 같다.

* 대부분의 리눅스 드라이버는 인터럽트를 통해 하드웨어 디바이스와 통신한다. 그래서 디바이스 드라이버 코드를 처음 분석할 때 인터럽트를 처리하는 함수나 코드를 먼저 확인한다. 인터럽트의 동작 방식을 잘 알고 있으면 디바이스 드라이버 코드를 빨리 이해할 수 있다.
* 인터럽트가 발생하면 프로세스는 이미 정해진 동작을 수행한다. 인터럽트 처리 과정을 숙지하면 프로세스가 스택 메모리 공간에서 어떻게 실행되는지 알게 된다.
* CPU 아키텍처(x86, ARM)에 따라 인터럽트 벡터는 달리 동작한다. 인터럽트 벡터가 어떻게 동작하는지 잘 알면 자연히 ARM 아키텍처의 동작 원리에 대해 더 많이 알게 된다.

### 리눅스 커널에서의 인터럽트 처리 흐름

## 인터럽트 컨텍스트

### 인터럽트 컨텍스트란?

인터럽트 컨텍스트와 관련된 코드를 분석하면서 인터럽트 컨텍스트의 세부 동작 방식을 알아보기에 앞서 인터럽트 컨텍스트의 개념을 알아본다. 먼저 인터럽트 컨텍스트를 간단히 정의하자면 "현재 실행 중인 프로세스가 현재 인터럽트를 처리 중"이라는 것을 의미한다. 즉, 현재 실행 중인 함수가 인터럽트 핸들러이거나 인터럽트 핸들러에서 호출된 함수라는 것이다.

#### 리눅스 커널에서 컨텍스트란?

인터럽트 컨텍스트의 의미를 파악하기 위해 먼저 '컨텍스트'가 무엇인지 알아볼 필요가 있다. 컨텍스트란 '프로세스 실행 그 자체'를 의미하며 현재 실행 중인 프로세스 정보를 담고 있는 레지스터 세트로 표현할 수 있다.

#### 인터럽트 컨텍스트란 무엇인가?

인터럽트 컨텍스트란 용어의 뜻은 "인터럽트 처리 중"이란 뜻이다.

인터럽트가 발생하면 인터럽트 벡터 주소부터 인터럽트 핸들러까지 함수 흐름으로 인터럽트를 처리한다. 인터럽트 컨텍스트란 이 흐름 중 하나라고 볼 수 있다. 이를 풀어서 정리하면 현재 인터럽트 핸들러를 실행 중이면 인터럽트 컨텍스트이다. 인터럽트를 핸들링하는 중이기 때문이다.

#### 인터럽트 컨텍스트란 용어는 왜 배워야 할까?

인터럽트 컨텍스트라는 용어를 알아야 하는 이유는 무엇인가? 리눅스 커널 전반에 이 용어가 사용되고, 이 개념을 적용한 커널 코드가 많이 때문이다. 인터럽트 컨텍스트에 대한 공학적 의미를 이해하지 못하면 다른 코드를 이해하기 어렵다.

### ftrace와 커널 로그로 인터럽트 컨텍스트 확인해보기

#### 인터럽트 동작을 확인하기 위한 ftrace 설정

#### 라즈베리 파이에서 받은 ftrace로 인터럽트 컨텍스트 확인

#### 커널 로그를 이용한 인터럽트 컨텍스트 확인

### in_interrupt() 함수란?

#### in_interrupt() 함수를 써서 만든 패치 코드

#### in_interrupt() 함수 관련 리눅스 커널 패치 소개

#### in_interrupt() 함수 코드 분석하기

#### __irq_enter() 함수 분석

#### __irq_exit() 함수 분석

#### 라즈베리파이에서 in_interrupt() 함수의 동작 방식 확인

### 인터럽트 컨텍스트에서 스케줄링을 하면 어떻게 될까?

#### 인터럽트 컨텍스트에서 스케줄링을 지원하는 함수를 호출할 때 발생하는 커널 패닉

#### 인터럽트 컨텍스트에서 스케줄링 지원 함수 호출 시 발생하는 커널 패닉 사례 연구

## 인터럽트 핸들러는 언제 호출될까?

### 인터럽트 벡터 분석

#### ARMv7 아키텍처 관점에서 본 인터럽트의 처리 방식

#### 인터럽트의 벡터의 구현부 분석

#### __irq_svc 레이블 코드 분석으로 세부 동작 알아보기

### 인터럽트 벡터에서 스택 푸시 확인

### 인터럽트 핸들러의 호출 흐름 분석

## 인터럽트 핸들러는 어떻게 등록할까?

### 인터럽트 핸들러의 등록 과정 분석

#### request_irq() 함수 소개

#### request_irq() 함수를 이용해 인터럽트를 초기화하는 라즈비안 코드 분석

#### request_irq() 함수와 request_threaded_irq() 함수 분석

### 인터럽트 핸들러의 초기화 과정 디버깅

#### 인터럽트를 초기화한 후 인터럽트 디스크립터 확인

### 인터럽트 핸들러 등록 시 플래그 설정

#### 인터럽트 플래그 설정 예제

## 인터럽트 디스크립터

### 인터럽트 디스크립터란?

#### 리눅스 커널에서의 디스크립터의 의미

#### 인터럽트 디스크립터 소개

#### 인터럽트 디스크립터 구조체 알아보기

### 인터럽트 발생 횟수는 어떻게 저장할까?

#### 인터럽트 실행 횟수를 점검하는 패치 코드 실습

## 인터럽트는 언제 비활성화해야 할까?

#### 인터럽트 발생 비활성화 예제

#### 익셉션 발생 후 인터럽트 발생을 비활성화하는 예제

## 인터럽트 디버깅

### /proc/interrupts

#### /proc/interrupts 메시지를 이용한 인터럽트의 속성 분석

#### show_interrupts() 함수 분석

### ftrace 인터럽트 이벤트

#### ftrace의 irq_handler_entry와 irq_handler_exit 이벤트 설정

#### ftrace : irq_handler_entry/irq_handler_exit 이벤트 메시지 분석

#### ftrace의 irq_handler_entry/irq_handler_exit 이벤트를 출력하는 커널 함수 분석

### ftrace로 인터럽트 핸들러 함수 파악하기

